:NewParser
:ParseOnly

:GOInterp
:GraphOpt
class Pair(x, y)
fun mktup2(x, y) = mktup(x, y)
fun mktup(x, y) = Pair(x, y)
fun foo() =
  mktup2(1, 2)
foo()
//│ |#class| |Pair|(|x|,| |y|)|↵|#fun| |mktup2|(|x|,| |y|)| |#=| |mktup|(|x|,| |y|)|↵|#fun| |mktup|(|x|,| |y|)| |#=| |Pair|(|x|,| |y|)|↵|#fun| |foo|(||)| |#=|→|mktup2|(|1|,| |2|)|←|↵|foo|(||)|
//│ Parsed: {class Pair(x, y,) {}; fun mktup2 = (x, y,) => mktup(x, y,); fun mktup = (x, y,) => Pair(x, y,); fun foo = () => {mktup2(1, 2,)}; foo()}
//│ Parsed:
//│ TypingUnit(NuTypeDef(class, Pair, (), Tup(_: Var(x), _: Var(y)), (), None, None, TypingUnit()), NuFunDef(None, mktup2, None, [], Lam(Tup(_: Var(x), _: Var(y)), App(Var(mktup), Tup(_: Var(x), _: Var(y))))), NuFunDef(None, mktup, None, [], Lam(Tup(_: Var(x), _: Var(y)), App(Var(Pair), Tup(_: Var(x), _: Var(y))))), NuFunDef(None, foo, None, [], Lam(Tup(), Blk(...))), App(Var(foo), Tup()))
//│ 
//│ GraphOpt:
//│ GOProgram({ClassInfo(0, Pair, [x,y])}, {
//│ Def(0, mktup2, [_x0,_y0], [{}], 
//│ None, 1, 
//│ let* (_x1) = mktup(_x0,_y0)
//│   in _x1
//│ )
//│ Def(1, mktup, [_x2,_y1], [{}], 
//│ None, 1, 
//│ let _x3 = Pair(_x2,_y1)
//│   in _x3
//│ )
//│ Def(2, foo, [], [{}], 
//│ None, 1, 
//│ let* (_x4) = mktup2(1,2)
//│   in _x4
//│ )
//│ },
//│ let* (_x5) = foo()
//│   in _x5)
//│ 
//│ Promoted ------------------------------------
//│ GOProgram({ClassInfo(0, Pair, [x,y])}, {
//│ Def(0, mktup2, [_x0,_y0], [{EDirect},{EDirect}], 
//│ Some(ICtor(Pair)), 1, 
//│ let* (_x1) = mktup(_x0,_y0)
//│   in _x1
//│ )
//│ Def(1, mktup, [_x2,_y1], [{EDirect},{EDirect}], 
//│ Some(ICtor(Pair)), 1, 
//│ let _x3 = Pair(_x2,_y1)
//│   in _x3
//│ )
//│ Def(2, foo, [], [], 
//│ Some(ICtor(Pair)), 1, 
//│ let* (_x4) = mktup2(1,2)
//│   in _x4
//│ )
//│ },
//│ let* (_x5) = foo()
//│   in _x5)
//│ 
//│ Interpreted ------------------------------
//│ Pair(1,2)
//│ 
//│ 
//│ 
//│ Interpreted ------------------------------
//│ Pair(1,2)

:GraphOpt
class Pair(x, y)
fun foo(pair) =
  if pair is
    Pair(x, y) then Pair(x, y)
fun bar() =
  foo(Pair(1, 2))
bar()
//│ |#class| |Pair|(|x|,| |y|)|↵|#fun| |foo|(|pair|)| |#=|→|#if| |pair| |is|→|Pair|(|x|,| |y|)| |#then| |Pair|(|x|,| |y|)|←|←|↵|#fun| |bar|(||)| |#=|→|foo|(|Pair|(|1|,| |2|)|)|←|↵|bar|(||)|
//│ Parsed: {class Pair(x, y,) {}; fun foo = (pair,) => {if pair is ‹(Pair(x, y,)) then Pair(x, y,)›}; fun bar = () => {foo(Pair(1, 2,),)}; bar()}
//│ Parsed:
//│ TypingUnit(NuTypeDef(class, Pair, (), Tup(_: Var(x), _: Var(y)), (), None, None, TypingUnit()), NuFunDef(None, foo, None, [], Lam(Tup(_: Var(pair)), Blk(...))), NuFunDef(None, bar, None, [], Lam(Tup(), Blk(...))), App(Var(bar), Tup()))
//│ 
//│ GraphOpt:
//│ GOProgram({ClassInfo(0, Pair, [x,y])}, {
//│ Def(0, foo, [_pair0], [{}], 
//│ None, 1, 
//│ let join _j0(_x3) = _x3
//│   in case _pair0 of
//│     Pair => let _x0 = _pair0.y
//│       in let _x1 = _pair0.x
//│         in let _x2 = Pair(_x1,_x0)
//│           in jump _j0(_x2)
//│ )
//│ Def(1, bar, [], [{}], 
//│ None, 1, 
//│ let _x4 = Pair(1,2)
//│   in let* (_x5) = foo(_x4)
//│     in _x5
//│ )
//│ },
//│ let* (_x6) = bar()
//│   in _x6)
//│ 
//│ Promoted ------------------------------------
//│ GOProgram({ClassInfo(0, Pair, [x,y])}, {
//│ Def(0, foo, [_pair0], [{EDestruct，EDirect，ESelect(y)，ESelect(x)}], 
//│ Some(ICtor(Pair)), 1, 
//│ case _pair0 of
//│   Pair => let _x0 = _pair0.y
//│     in let _x1 = _pair0.x
//│       in let _x2 = Pair(_x1,_x0)
//│         in _x2
//│ )
//│ Def(1, bar, [], [], 
//│ Some(ICtor(Pair)), 1, 
//│ let _x4 = Pair(1,2)
//│   in let* (_x5) = foo(_x4)
//│     in _x5
//│ )
//│ },
//│ let* (_x6) = bar()
//│   in _x6)
//│ 
//│ Optimized ------------------------------
//│ GOProgram({ClassInfo(0, Pair, [x,y])}, {
//│ Def(1, bar, [], [], 
//│ Some(ICtor(Pair)), 1, 
//│ let* (_x5) = __foo$D0$S0(2,1)
//│   in _x5
//│ )
//│ Def(5, __foo$D0$S0, [_pair0_y,_pair0_x], [{EDirect},{EDirect}], 
//│ Some(ICtor(Pair)), 1, 
//│ let _x2 = Pair(_pair0_x,_pair0_y)
//│   in _x2
//│ )
//│ },
//│ let* (_x6) = bar()
//│   in _x6)



:GraphOpt
class Pair(x, y) {}
fun silly(pair) =
  let _ = 0
  let n = if pair is
    Pair(x1, x2) then
      if pair is
        Pair (x3, x4) then x3 + 1
  n + 1
fun foo() =
    let a = Pair(0, 1)
    let b = silly(a)
    b
foo()
//│ |#class| |Pair|(|x|,| |y|)| |{||}|↵|#fun| |silly|(|pair|)| |#=|→|#let| |_| |#=| |0|↵|#let| |n| |#=| |#if| |pair| |is|→|Pair|(|x1|,| |x2|)| |#then|→|#if| |pair| |is|→|Pair| |(|x3|,| |x4|)| |#then| |x3| |+| |1|←|←|←|↵|n| |+| |1|←|↵|#fun| |foo|(||)| |#=|→|#let| |a| |#=| |Pair|(|0|,| |1|)|↵|#let| |b| |#=| |silly|(|a|)|↵|b|←|↵|foo|(||)|
//│ Parsed: {class Pair(x, y,) {}; fun silly = (pair,) => {let _ = 0; let n = if pair is ‹(Pair(x1, x2,)) then {if pair is ‹(Pair(x3, x4,)) then +(x3,)(1,)›}›; +(n,)(1,)}; fun foo = () => {let a = Pair(0, 1,); let b = silly(a,); b}; foo()}
//│ Parsed:
//│ TypingUnit(NuTypeDef(class, Pair, (), Tup(_: Var(x), _: Var(y)), (), None, None, TypingUnit()), NuFunDef(None, silly, None, [], Lam(Tup(_: Var(pair)), Blk(...))), NuFunDef(None, foo, None, [], Lam(Tup(), Blk(...))), App(Var(foo), Tup()))
//│ 
//│ GraphOpt:
//│ GOProgram({ClassInfo(0, Pair, [x,y])}, {
//│ Def(0, silly, [_pair0], [{}], 
//│ None, 1, 
//│ let _x0 = 0
//│   in let join _j0(_x7) = let _x8 = +(_x7,1)
//│         in _x8
//│     in case _pair0 of
//│       Pair => let _x1 = _pair0.y
//│         in let _x2 = _pair0.x
//│           in let join _j1(_x6) = jump _j0(_x6)
//│             in case _pair0 of
//│               Pair => let _x3 = _pair0.y
//│                 in let _x4 = _pair0.x
//│                   in let _x5 = +(_x4,1)
//│                     in jump _j1(_x5)
//│ )
//│ Def(1, foo, [], [{}], 
//│ None, 1, 
//│ let _x9 = Pair(0,1)
//│   in let* (_x10) = silly(_x9)
//│     in _x10
//│ )
//│ },
//│ let* (_x11) = foo()
//│   in _x11)
//│ 
//│ Promoted ------------------------------------
//│ GOProgram({ClassInfo(0, Pair, [x,y])}, {
//│ Def(0, silly, [_pair0], [{EDestruct，EDirect，ESelect(x)}], 
//│ None, 1, 
//│ case _pair0 of
//│   Pair => case _pair0 of
//│     Pair => let _x4 = _pair0.x
//│       in let _x5 = +(_x4,1)
//│         in jump _j1(_x5)
//│ )
//│ Def(1, foo, [], [], 
//│ None, 1, 
//│ let _x9 = Pair(0,1)
//│   in let* (_x10) = silly(_x9)
//│     in _x10
//│ )
//│ Def(2, @join _j0, [_x7], [{EDirect}], 
//│ None, 1, 
//│ let _x8 = +(_x7,1)
//│   in _x8
//│ )
//│ Def(3, @join _j1, [_x6], [{EDirect}], 
//│ None, 1, 
//│ jump _j0(_x6)
//│ )
//│ },
//│ let* (_x11) = foo()
//│   in _x11)
//│ 
//│ Optimized ------------------------------
//│ GOProgram({ClassInfo(0, Pair, [x,y])}, {
//│ Def(1, foo, [], [], 
//│ None, 1, 
//│ let _x9 = Pair(0,1)
//│   in let* (_x10) = _silly$D0(_x9)
//│     in _x10
//│ )
//│ Def(2, @join _j0, [_x7], [{EDirect}], 
//│ None, 1, 
//│ let _x8 = +(_x7,1)
//│   in _x8
//│ )
//│ Def(3, @join _j1, [_x6], [{EDirect}], 
//│ None, 1, 
//│ jump _j0(_x6)
//│ )
//│ Def(5, _silly$D0, [_pair0], [{EDestruct，EDirect，ESelect(x)}], 
//│ None, 1, 
//│ case _pair0 of
//│   Pair => let _x4 = _pair0.x
//│     in let _x5 = +(_x4,1)
//│       in jump _j1(_x5)
//│ )
//│ },
//│ let* (_x11) = foo()
//│   in _x11)
//│ 
//│ Optimized ------------------------------
//│ GOProgram({ClassInfo(0, Pair, [x,y])}, {
//│ Def(1, foo, [], [], 
//│ None, 1, 
//│ let* (_x10) = ___silly$D0$D0$S0(0)
//│   in _x10
//│ )
//│ Def(2, @join _j0, [_x7], [{EDirect}], 
//│ None, 1, 
//│ let _x8 = +(_x7,1)
//│   in _x8
//│ )
//│ Def(3, @join _j1, [_x6], [{EDirect}], 
//│ None, 1, 
//│ jump _j0(_x6)
//│ )
//│ Def(8, ___silly$D0$D0$S0, [_pair0_x], [{EDirect}], 
//│ None, 1, 
//│ let _x5 = +(_pair0_x,1)
//│   in jump _j1(_x5)
//│ )
//│ },
//│ let* (_x11) = foo()
//│   in _x11)




:GraphOpt
class Pair(x, y)
fun inc_fst(pair) =
  let c = 2
  if pair is
    Pair(x1, x2) then x1 + c
fun foo() =
    let a = Pair(0, 1)
    let b = inc_fst(a)
    b
foo()
//│ |#class| |Pair|(|x|,| |y|)|↵|#fun| |inc_fst|(|pair|)| |#=|→|#let| |c| |#=| |2|↵|#if| |pair| |is|→|Pair|(|x1|,| |x2|)| |#then| |x1| |+| |c|←|←|↵|#fun| |foo|(||)| |#=|→|#let| |a| |#=| |Pair|(|0|,| |1|)|↵|#let| |b| |#=| |inc_fst|(|a|)|↵|b|←|↵|foo|(||)|
//│ Parsed: {class Pair(x, y,) {}; fun inc_fst = (pair,) => {let c = 2; if pair is ‹(Pair(x1, x2,)) then +(x1,)(c,)›}; fun foo = () => {let a = Pair(0, 1,); let b = inc_fst(a,); b}; foo()}
//│ Parsed:
//│ TypingUnit(NuTypeDef(class, Pair, (), Tup(_: Var(x), _: Var(y)), (), None, None, TypingUnit()), NuFunDef(None, inc_fst, None, [], Lam(Tup(_: Var(pair)), Blk(...))), NuFunDef(None, foo, None, [], Lam(Tup(), Blk(...))), App(Var(foo), Tup()))
//│ 
//│ GraphOpt:
//│ GOProgram({ClassInfo(0, Pair, [x,y])}, {
//│ Def(0, inc_fst, [_pair0], [{}], 
//│ None, 1, 
//│ let _x0 = 2
//│   in let join _j0(_x4) = _x4
//│     in case _pair0 of
//│       Pair => let _x1 = _pair0.y
//│         in let _x2 = _pair0.x
//│           in let _x3 = +(_x2,_x0)
//│             in jump _j0(_x3)
//│ )
//│ Def(1, foo, [], [{}], 
//│ None, 1, 
//│ let _x5 = Pair(0,1)
//│   in let* (_x6) = inc_fst(_x5)
//│     in _x6
//│ )
//│ },
//│ let* (_x7) = foo()
//│   in _x7)
//│ 
//│ Promoted ------------------------------------
//│ GOProgram({ClassInfo(0, Pair, [x,y])}, {
//│ Def(0, inc_fst, [_pair0], [{EDestruct，EDirect，ESelect(x)}], 
//│ None, 1, 
//│ case _pair0 of
//│   Pair => let _x2 = _pair0.x
//│     in let _x3 = +(_x2,2)
//│       in _x3
//│ )
//│ Def(1, foo, [], [], 
//│ None, 1, 
//│ let _x5 = Pair(0,1)
//│   in let* (_x6) = inc_fst(_x5)
//│     in _x6
//│ )
//│ },
//│ let* (_x7) = foo()
//│   in _x7)
//│ 
//│ Optimized ------------------------------
//│ GOProgram({ClassInfo(0, Pair, [x,y])}, {
//│ Def(1, foo, [], [], 
//│ None, 1, 
//│ let* (_x6) = __inc_fst$D0$S0(0)
//│   in _x6
//│ )
//│ Def(5, __inc_fst$D0$S0, [_pair0_x], [{EDirect}], 
//│ None, 1, 
//│ let _x3 = +(_pair0_x,2)
//│   in _x3
//│ )
//│ },
//│ let* (_x7) = foo()
//│   in _x7)

:GraphOpt
class Pair(x, y)
fun inc_fst(pair) =
  let _ = 0
  if pair is
    Pair(x1, x2) then x2 + 1
fun foo() =
    let b = inc_fst(Pair(0, 1))
    b
foo()
//│ |#class| |Pair|(|x|,| |y|)|↵|#fun| |inc_fst|(|pair|)| |#=|→|#let| |_| |#=| |0|↵|#if| |pair| |is|→|Pair|(|x1|,| |x2|)| |#then| |x2| |+| |1|←|←|↵|#fun| |foo|(||)| |#=|→|#let| |b| |#=| |inc_fst|(|Pair|(|0|,| |1|)|)|↵|b|←|↵|foo|(||)|
//│ Parsed: {class Pair(x, y,) {}; fun inc_fst = (pair,) => {let _ = 0; if pair is ‹(Pair(x1, x2,)) then +(x2,)(1,)›}; fun foo = () => {let b = inc_fst(Pair(0, 1,),); b}; foo()}
//│ Parsed:
//│ TypingUnit(NuTypeDef(class, Pair, (), Tup(_: Var(x), _: Var(y)), (), None, None, TypingUnit()), NuFunDef(None, inc_fst, None, [], Lam(Tup(_: Var(pair)), Blk(...))), NuFunDef(None, foo, None, [], Lam(Tup(), Blk(...))), App(Var(foo), Tup()))
//│ 
//│ GraphOpt:
//│ GOProgram({ClassInfo(0, Pair, [x,y])}, {
//│ Def(0, inc_fst, [_pair0], [{}], 
//│ None, 1, 
//│ let _x0 = 0
//│   in let join _j0(_x4) = _x4
//│     in case _pair0 of
//│       Pair => let _x1 = _pair0.y
//│         in let _x2 = _pair0.x
//│           in let _x3 = +(_x1,1)
//│             in jump _j0(_x3)
//│ )
//│ Def(1, foo, [], [{}], 
//│ None, 1, 
//│ let _x5 = Pair(0,1)
//│   in let* (_x6) = inc_fst(_x5)
//│     in _x6
//│ )
//│ },
//│ let* (_x7) = foo()
//│   in _x7)
//│ 
//│ Promoted ------------------------------------
//│ GOProgram({ClassInfo(0, Pair, [x,y])}, {
//│ Def(0, inc_fst, [_pair0], [{EDestruct，EDirect，ESelect(y)}], 
//│ None, 1, 
//│ case _pair0 of
//│   Pair => let _x1 = _pair0.y
//│     in let _x3 = +(_x1,1)
//│       in _x3
//│ )
//│ Def(1, foo, [], [], 
//│ None, 1, 
//│ let _x5 = Pair(0,1)
//│   in let* (_x6) = inc_fst(_x5)
//│     in _x6
//│ )
//│ },
//│ let* (_x7) = foo()
//│   in _x7)
//│ 
//│ Optimized ------------------------------
//│ GOProgram({ClassInfo(0, Pair, [x,y])}, {
//│ Def(1, foo, [], [], 
//│ None, 1, 
//│ let* (_x6) = __inc_fst$D0$S0(1)
//│   in _x6
//│ )
//│ Def(5, __inc_fst$D0$S0, [_pair0_y], [{EDirect}], 
//│ None, 1, 
//│ let _x3 = +(_pair0_y,1)
//│   in _x3
//│ )
//│ },
//│ let* (_x7) = foo()
//│   in _x7)

:GraphOpt
class Left(x)
class Right(y)
fun foo(a, b) =
  let t = if a is
    Left(x) then Left(x + 1)
    Right(y) then Right(b)
  if t is
    Left(x) then x
    Right(y) then y
fun bar() =
  foo(Right(2), 2)
bar()
//│ |#class| |Left|(|x|)|↵|#class| |Right|(|y|)|↵|#fun| |foo|(|a|,| |b|)| |#=|→|#let| |t| |#=| |#if| |a| |is|→|Left|(|x|)| |#then| |Left|(|x| |+| |1|)|↵|Right|(|y|)| |#then| |Right|(|b|)|←|↵|#if| |t| |is|→|Left|(|x|)| |#then| |x|↵|Right|(|y|)| |#then| |y|←|←|↵|#fun| |bar|(||)| |#=|→|foo|(|Right|(|2|)|,| |2|)|←|↵|bar|(||)|
//│ Parsed: {class Left(x,) {}; class Right(y,) {}; fun foo = (a, b,) => {let t = if a is ‹(Left(x,)) then Left(+(x,)(1,),); (Right(y,)) then Right(b,)›; if t is ‹(Left(x,)) then x; (Right(y,)) then y›}; fun bar = () => {foo(Right(2,), 2,)}; bar()}
//│ Parsed:
//│ TypingUnit(NuTypeDef(class, Left, (), Tup(_: Var(x)), (), None, None, TypingUnit()), NuTypeDef(class, Right, (), Tup(_: Var(y)), (), None, None, TypingUnit()), NuFunDef(None, foo, None, [], Lam(Tup(_: Var(a), _: Var(b)), Blk(...))), NuFunDef(None, bar, None, [], Lam(Tup(), Blk(...))), App(Var(bar), Tup()))
//│ 
//│ GraphOpt:
//│ GOProgram({ClassInfo(0, Left, [x]),ClassInfo(1, Right, [y])}, {
//│ Def(0, foo, [_a0,_b0], [{}], 
//│ None, 1, 
//│ let join _j0(_x5) = let join _j1(_x8) = _x8
//│       in case _x5 of
//│         Left => let _x6 = _x5.x
//│           in jump _j1(_x6)
//│         Right => let _x7 = _x5.y
//│           in jump _j1(_x7)
//│   in case _a0 of
//│     Left => let _x0 = _a0.x
//│       in let _x1 = +(_x0,1)
//│         in let _x2 = Left(_x1)
//│           in jump _j0(_x2)
//│     Right => let _x3 = _a0.y
//│       in let _x4 = Right(_b0)
//│         in jump _j0(_x4)
//│ )
//│ Def(1, bar, [], [{}], 
//│ None, 1, 
//│ let _x9 = Right(2)
//│   in let* (_x10) = foo(_x9,2)
//│     in _x10
//│ )
//│ },
//│ let* (_x11) = bar()
//│   in _x11)
//│ 
//│ Promoted ------------------------------------
//│ GOProgram({ClassInfo(0, Left, [x]),ClassInfo(1, Right, [y])}, {
//│ Def(0, foo, [_a0,_b0], [{EDestruct，EDirect，ESelect(x)},{EDirect}], 
//│ None, 1, 
//│ case _a0 of
//│   Left => let _x0 = _a0.x
//│     in let _x1 = +(_x0,1)
//│       in let _x2 = Left(_x1)
//│         in jump _j0(_x2)
//│   Right => let _x4 = Right(_b0)
//│     in jump _j0(_x4)
//│ )
//│ Def(1, bar, [], [], 
//│ None, 1, 
//│ let _x9 = Right(2)
//│   in let* (_x10) = foo(_x9,2)
//│     in _x10
//│ )
//│ Def(2, @join _j0, [_x5], [{EDestruct，EDirect，ESelect(x)，ESelect(y)}], 
//│ None, 1, 
//│ case _x5 of
//│   Left => let _x6 = _x5.x
//│     in _x6
//│   Right => let _x7 = _x5.y
//│     in _x7
//│ )
//│ },
//│ let* (_x11) = bar()
//│   in _x11)
//│ 
//│ Optimized ------------------------------
//│ GOProgram({ClassInfo(0, Left, [x]),ClassInfo(1, Right, [y])}, {
//│ Def(1, bar, [], [], 
//│ None, 1, 
//│ let* (_x10) = _foo$D1(2)
//│   in _x10
//│ )
//│ Def(2, @join _j0, [_x5], [{EDestruct，EDirect，ESelect(x)，ESelect(y)}], 
//│ None, 1, 
//│ case _x5 of
//│   Left => let _x6 = _x5.x
//│     in _x6
//│   Right => let _x7 = _x5.y
//│     in _x7
//│ )
//│ Def(6, _foo$D1, [_b0], [{EDirect}], 
//│ None, 1, 
//│ let _x4 = Right(_b0)
//│   in jump _j0(_x4)
//│ )
//│ },
//│ let* (_x11) = bar()
//│   in _x11)
//│ 
//│ Optimized ------------------------------
//│ GOProgram({ClassInfo(0, Left, [x]),ClassInfo(1, Right, [y])}, {
//│ Def(1, bar, [], [], 
//│ None, 1, 
//│ 2
//│ )
//│ },
//│ let* (_x11) = bar()
//│   in _x11)

:GraphOpt
class True
class False
class Pair(x, y)
fun foo(a) = a.x + a.y
fun bar() =
  foo(Pair(1, 0))
bar()
//│ |#class| |True|↵|#class| |False|↵|#class| |Pair|(|x|,| |y|)|↵|#fun| |foo|(|a|)| |#=| |a|.x| |+| |a|.y|↵|#fun| |bar|(||)| |#=|→|foo|(|Pair|(|1|,| |0|)|)|←|↵|bar|(||)|
//│ Parsed: {class True {}; class False {}; class Pair(x, y,) {}; fun foo = (a,) => +((a).x,)((a).y,); fun bar = () => {foo(Pair(1, 0,),)}; bar()}
//│ Parsed:
//│ TypingUnit(NuTypeDef(class, True, (), Tup(), (), None, None, TypingUnit()), NuTypeDef(class, False, (), Tup(), (), None, None, TypingUnit()), NuTypeDef(class, Pair, (), Tup(_: Var(x), _: Var(y)), (), None, None, TypingUnit()), NuFunDef(None, foo, None, [], Lam(Tup(_: Var(a)), App(App(Var(+), Tup(_: Sel(Var(a), x))), Tup(_: Sel(Var(a), y))))), NuFunDef(None, bar, None, [], Lam(Tup(), Blk(...))), App(Var(bar), Tup()))
//│ 
//│ GraphOpt:
//│ GOProgram({ClassInfo(0, True, []),ClassInfo(1, False, []),ClassInfo(2, Pair, [x,y])}, {
//│ Def(0, foo, [_a0], [{}], 
//│ None, 1, 
//│ let _x0 = _a0.x
//│   in let _x1 = _a0.y
//│     in let _x2 = +(_x0,_x1)
//│       in _x2
//│ )
//│ Def(1, bar, [], [{}], 
//│ None, 1, 
//│ let _x3 = Pair(1,0)
//│   in let* (_x4) = foo(_x3)
//│     in _x4
//│ )
//│ },
//│ let* (_x5) = bar()
//│   in _x5)
//│ 
//│ Promoted ------------------------------------
//│ GOProgram({ClassInfo(0, True, []),ClassInfo(1, False, []),ClassInfo(2, Pair, [x,y])}, {
//│ Def(0, foo, [_a0], [{ESelect(x)，ESelect(y)}], 
//│ None, 1, 
//│ let _x0 = _a0.x
//│   in let _x1 = _a0.y
//│     in let _x2 = +(_x0,_x1)
//│       in _x2
//│ )
//│ Def(1, bar, [], [], 
//│ None, 1, 
//│ let _x3 = Pair(1,0)
//│   in let* (_x4) = foo(_x3)
//│     in _x4
//│ )
//│ },
//│ let* (_x5) = bar()
//│   in _x5)
//│ 
//│ Optimized ------------------------------
//│ GOProgram({ClassInfo(0, True, []),ClassInfo(1, False, []),ClassInfo(2, Pair, [x,y])}, {
//│ Def(1, bar, [], [], 
//│ None, 1, 
//│ let* (_x4) = _foo$S0(1,0)
//│   in _x4
//│ )
//│ Def(2, _foo$S0, [_a0_x,_a0_y], [{EDirect},{EDirect}], 
//│ None, 1, 
//│ let _x2 = +(_a0_x,_a0_y)
//│   in _x2
//│ )
//│ },
//│ let* (_x5) = bar()
//│   in _x5)


:GraphOpt
class C1(x, y)
class C2(z)
fun foo(a) = if a is
  C1(x, y) then x
  C2(z) then z
fun bar() =
  foo(C1(0, 1))
bar()
//│ |#class| |C1|(|x|,| |y|)|↵|#class| |C2|(|z|)|↵|#fun| |foo|(|a|)| |#=| |#if| |a| |is|→|C1|(|x|,| |y|)| |#then| |x|↵|C2|(|z|)| |#then| |z|←|↵|#fun| |bar|(||)| |#=|→|foo|(|C1|(|0|,| |1|)|)|←|↵|bar|(||)|
//│ Parsed: {class C1(x, y,) {}; class C2(z,) {}; fun foo = (a,) => if a is ‹(C1(x, y,)) then x; (C2(z,)) then z›; fun bar = () => {foo(C1(0, 1,),)}; bar()}
//│ Parsed:
//│ TypingUnit(NuTypeDef(class, C1, (), Tup(_: Var(x), _: Var(y)), (), None, None, TypingUnit()), NuTypeDef(class, C2, (), Tup(_: Var(z)), (), None, None, TypingUnit()), NuFunDef(None, foo, None, [], Lam(Tup(_: Var(a)), If(IfOpApp(Var(a), Var(is), IfBlock(IfThen(App(Var(C1), Tup(_: Var(x), _: Var(y))), Var(x);IfThen(App(Var(C2), Tup(_: Var(z))), Var(z)), None))), NuFunDef(None, bar, None, [], Lam(Tup(), Blk(...))), App(Var(bar), Tup()))
//│ 
//│ GraphOpt:
//│ GOProgram({ClassInfo(0, C1, [x,y]),ClassInfo(1, C2, [z])}, {
//│ Def(0, foo, [_a0], [{}], 
//│ None, 1, 
//│ let join _j0(_x3) = _x3
//│   in case _a0 of
//│     C1 => let _x0 = _a0.y
//│       in let _x1 = _a0.x
//│         in jump _j0(_x1)
//│     C2 => let _x2 = _a0.z
//│       in jump _j0(_x2)
//│ )
//│ Def(1, bar, [], [{}], 
//│ None, 1, 
//│ let _x4 = C1(0,1)
//│   in let* (_x5) = foo(_x4)
//│     in _x5
//│ )
//│ },
//│ let* (_x6) = bar()
//│   in _x6)
//│ 
//│ Promoted ------------------------------------
//│ GOProgram({ClassInfo(0, C1, [x,y]),ClassInfo(1, C2, [z])}, {
//│ Def(0, foo, [_a0], [{EDestruct，EDirect，ESelect(x)，ESelect(z)}], 
//│ None, 1, 
//│ case _a0 of
//│   C1 => let _x1 = _a0.x
//│     in _x1
//│   C2 => let _x2 = _a0.z
//│     in _x2
//│ )
//│ Def(1, bar, [], [], 
//│ None, 1, 
//│ let _x4 = C1(0,1)
//│   in let* (_x5) = foo(_x4)
//│     in _x5
//│ )
//│ },
//│ let* (_x6) = bar()
//│   in _x6)
//│ 
//│ Optimized ------------------------------
//│ GOProgram({ClassInfo(0, C1, [x,y]),ClassInfo(1, C2, [z])}, {
//│ Def(1, bar, [], [], 
//│ None, 1, 
//│ 0
//│ )
//│ },
//│ let* (_x6) = bar()
//│   in _x6)

:GOInterp
:GraphOpt
class Pair(x, y)
fun foo(a, b) =
  let x1 = a.x
  let y1 = a.y
  let x2 = b.x
  let y2 = b.y
  x1 + y1 + x2 + y2
fun bar(c) =
  foo(Pair(0, 1), c)
  foo(c, Pair(2, 3))
  foo(Pair(0, 1), Pair(2, 3))
fun baz() =
  bar(Pair(4,5))
baz()
//│ |#class| |Pair|(|x|,| |y|)|↵|#fun| |foo|(|a|,| |b|)| |#=|→|#let| |x1| |#=| |a|.x|↵|#let| |y1| |#=| |a|.y|↵|#let| |x2| |#=| |b|.x|↵|#let| |y2| |#=| |b|.y|↵|x1| |+| |y1| |+| |x2| |+| |y2|←|↵|#fun| |bar|(|c|)| |#=|→|foo|(|Pair|(|0|,| |1|)|,| |c|)|↵|foo|(|c|,| |Pair|(|2|,| |3|)|)|↵|foo|(|Pair|(|0|,| |1|)|,| |Pair|(|2|,| |3|)|)|←|↵|#fun| |baz|(||)| |#=|→|bar|(|Pair|(|4|,|5|)|)|←|↵|baz|(||)|
//│ Parsed: {class Pair(x, y,) {}; fun foo = (a, b,) => {let x1 = (a).x; let y1 = (a).y; let x2 = (b).x; let y2 = (b).y; +(+(+(x1,)(y1,),)(x2,),)(y2,)}; fun bar = (c,) => {foo(Pair(0, 1,), c,); foo(c, Pair(2, 3,),); foo(Pair(0, 1,), Pair(2, 3,),)}; fun baz = () => {bar(Pair(4, 5,),)}; baz()}
//│ Parsed:
//│ TypingUnit(NuTypeDef(class, Pair, (), Tup(_: Var(x), _: Var(y)), (), None, None, TypingUnit()), NuFunDef(None, foo, None, [], Lam(Tup(_: Var(a), _: Var(b)), Blk(...))), NuFunDef(None, bar, None, [], Lam(Tup(_: Var(c)), Blk(...))), NuFunDef(None, baz, None, [], Lam(Tup(), Blk(...))), App(Var(baz), Tup()))
//│ 
//│ GraphOpt:
//│ GOProgram({ClassInfo(0, Pair, [x,y])}, {
//│ Def(0, foo, [_a0,_b0], [{}], 
//│ None, 1, 
//│ let _x0 = _a0.x
//│   in let _x1 = _a0.y
//│     in let _x2 = _b0.x
//│       in let _x3 = _b0.y
//│         in let _x4 = +(_x0,_x1)
//│           in let _x5 = +(_x4,_x2)
//│             in let _x6 = +(_x5,_x3)
//│               in _x6
//│ )
//│ Def(1, bar, [_c0], [{}], 
//│ None, 1, 
//│ let _x7 = Pair(0,1)
//│   in let* (_x8) = foo(_x7,_c0)
//│     in let _x9 = Pair(2,3)
//│       in let* (_x10) = foo(_c0,_x9)
//│         in let _x11 = Pair(0,1)
//│           in let _x12 = Pair(2,3)
//│             in let* (_x13) = foo(_x11,_x12)
//│               in _x13
//│ )
//│ Def(2, baz, [], [{}], 
//│ None, 1, 
//│ let _x14 = Pair(4,5)
//│   in let* (_x15) = bar(_x14)
//│     in _x15
//│ )
//│ },
//│ let* (_x16) = baz()
//│   in _x16)
//│ 
//│ Promoted ------------------------------------
//│ GOProgram({ClassInfo(0, Pair, [x,y])}, {
//│ Def(0, foo, [_a0,_b0], [{ESelect(x)，ESelect(y)},{ESelect(x)，ESelect(y)}], 
//│ None, 1, 
//│ let _x0 = _a0.x
//│   in let _x1 = _a0.y
//│     in let _x2 = _b0.x
//│       in let _x3 = _b0.y
//│         in let _x4 = +(_x0,_x1)
//│           in let _x5 = +(_x4,_x2)
//│             in let _x6 = +(_x5,_x3)
//│               in _x6
//│ )
//│ Def(1, bar, [_c0], [{EDirect，ESelect(x)，ESelect(y)}], 
//│ None, 1, 
//│ let _x7 = Pair(0,1)
//│   in let* (_x8) = foo(_x7,_c0)
//│     in let _x9 = Pair(2,3)
//│       in let* (_x10) = foo(_c0,_x9)
//│         in let _x11 = Pair(0,1)
//│           in let _x12 = Pair(2,3)
//│             in let* (_x13) = foo(_x11,_x12)
//│               in _x13
//│ )
//│ Def(2, baz, [], [], 
//│ None, 1, 
//│ let _x14 = Pair(4,5)
//│   in let* (_x15) = bar(_x14)
//│     in _x15
//│ )
//│ },
//│ let* (_x16) = baz()
//│   in _x16)
//│ 
//│ Interpreted ------------------------------
//│ 6
//│ 
//│ 
//│ Optimized ------------------------------
//│ GOProgram({ClassInfo(0, Pair, [x,y])}, {
//│ Def(1, bar, [_c0], [{ESelect(x)，ESelect(y)}], 
//│ None, 1, 
//│ let _x17 = _c0.x
//│   in let _x18 = _c0.y
//│     in let* (_x8) = _foo$S0(_x17,_x18,0,1)
//│       in let* (_x10) = _foo$S0(2,3,_x17,_x18)
//│         in let* (_x13) = _foo$S0(2,3,0,1)
//│           in _x13
//│ )
//│ Def(2, baz, [], [], 
//│ None, 1, 
//│ let _x14 = Pair(4,5)
//│   in let* (_x15) = bar(_x14)
//│     in _x15
//│ )
//│ Def(3, _foo$S0, [_b0_x,_b0_y,_a0_x,_a0_y], [{EDirect},{EDirect},{EDirect},{EDirect}], 
//│ None, 1, 
//│ let _x4 = +(_a0_x,_a0_y)
//│   in let _x5 = +(_x4,_b0_x)
//│     in let _x6 = +(_x5,_b0_y)
//│       in _x6
//│ )
//│ },
//│ let* (_x16) = baz()
//│   in _x16)
//│ 
//│ Optimized ------------------------------
//│ GOProgram({ClassInfo(0, Pair, [x,y])}, {
//│ Def(2, baz, [], [], 
//│ None, 1, 
//│ let* (_x15) = _bar$S0(4,5)
//│   in _x15
//│ )
//│ Def(3, _foo$S0, [_b0_x,_b0_y,_a0_x,_a0_y], [{EDirect},{EDirect},{EDirect},{EDirect}], 
//│ None, 1, 
//│ let _x4 = +(_a0_x,_a0_y)
//│   in let _x5 = +(_x4,_b0_x)
//│     in let _x6 = +(_x5,_b0_y)
//│       in _x6
//│ )
//│ Def(4, _bar$S0, [_c0_x,_c0_y], [{EDirect},{EDirect}], 
//│ None, 1, 
//│ let* (_x8) = _foo$S0(_c0_x,_c0_y,0,1)
//│   in let* (_x10) = _foo$S0(2,3,_c0_x,_c0_y)
//│     in let* (_x13) = _foo$S0(2,3,0,1)
//│       in _x13
//│ )
//│ },
//│ let* (_x16) = baz()
//│   in _x16)
//│ 
//│ 
//│ Interpreted ------------------------------
//│ 6

:GraphOpt
class Pair(x, y)
fun foo() =
  let p = Pair(0, 1)
  let b = p.x
  b
foo()
//│ |#class| |Pair|(|x|,| |y|)|↵|#fun| |foo|(||)| |#=|→|#let| |p| |#=| |Pair|(|0|,| |1|)|↵|#let| |b| |#=| |p|.x|↵|b|←|↵|foo|(||)|
//│ Parsed: {class Pair(x, y,) {}; fun foo = () => {let p = Pair(0, 1,); let b = (p).x; b}; foo()}
//│ Parsed:
//│ TypingUnit(NuTypeDef(class, Pair, (), Tup(_: Var(x), _: Var(y)), (), None, None, TypingUnit()), NuFunDef(None, foo, None, [], Lam(Tup(), Blk(...))), App(Var(foo), Tup()))
//│ 
//│ GraphOpt:
//│ GOProgram({ClassInfo(0, Pair, [x,y])}, {
//│ Def(0, foo, [], [{}], 
//│ None, 1, 
//│ let _x0 = Pair(0,1)
//│   in let _x1 = _x0.x
//│     in _x1
//│ )
//│ },
//│ let* (_x2) = foo()
//│   in _x2)
//│ 
//│ Promoted ------------------------------------
//│ GOProgram({ClassInfo(0, Pair, [x,y])}, {
//│ Def(0, foo, [], [], 
//│ None, 1, 
//│ 0
//│ )
//│ },
//│ let* (_x2) = foo()
//│   in _x2)

