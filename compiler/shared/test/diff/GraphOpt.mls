:NewParser
:ParseOnly

:GraphOpt
class Pair(x, y)
fun mktup2(x, y) = mktup(x, y)
fun mktup(x, y) = Pair(x, y)
fun foo() =
  mktup2(1, 2)
foo()
//│ |#class| |Pair|(|x|,| |y|)|↵|#fun| |mktup2|(|x|,| |y|)| |#=| |mktup|(|x|,| |y|)|↵|#fun| |mktup|(|x|,| |y|)| |#=| |Pair|(|x|,| |y|)|↵|#fun| |foo|(||)| |#=|→|mktup2|(|1|,| |2|)|←|↵|foo|(||)|
//│ Parsed: {class Pair(x, y,) {}; fun mktup2 = (x, y,) => mktup(x, y,); fun mktup = (x, y,) => Pair(x, y,); fun foo = () => {mktup2(1, 2,)}; foo()}
//│ Parsed:
//│ TypingUnit(NuTypeDef(class, Pair, (), Tup(_: Var(x), _: Var(y)), (), None, None, TypingUnit()), NuFunDef(None, mktup2, None, [], Lam(Tup(_: Var(x), _: Var(y)), App(Var(mktup), Tup(_: Var(x), _: Var(y))))), NuFunDef(None, mktup, None, [], Lam(Tup(_: Var(x), _: Var(y)), App(Var(Pair), Tup(_: Var(x), _: Var(y))))), NuFunDef(None, foo, None, [], Lam(Tup(), Blk(...))), App(Var(foo), Tup()))
//│ 
//│ GraphOpt:
//│ GOProgram({ClassInfo(0, Pair, [x,y])}, {
//│ Def(0, mktup2, [x,y], [{}], 
//│ None, 1, 
//│ let* (x0) = mktup(x,y)
//│   in x0
//│ )
//│ Def(1, mktup, [x,y], [{}], 
//│ None, 1, 
//│ let x1 = Pair(x,y)
//│   in x1
//│ )
//│ Def(2, foo, [], [{}], 
//│ None, 1, 
//│ let* (x2) = mktup2(1,2)
//│   in x2
//│ )
//│ },
//│ let* (x3) = foo()
//│   in x3)
//│ 
//│ Promoted ------------------------------------
//│ GOProgram({ClassInfo(0, Pair, [x,y])}, {
//│ Def(0, mktup2, [x,y], [{EDirect},{EDirect}], 
//│ Some(ICtor(Pair)), 1, 
//│ let* (x0) = mktup(x,y)
//│   in x0
//│ )
//│ Def(1, mktup, [x,y], [{EDirect},{EDirect}], 
//│ Some(ICtor(Pair)), 1, 
//│ let x1 = Pair(x,y)
//│   in x1
//│ )
//│ Def(2, foo, [], [], 
//│ Some(ICtor(Pair)), 1, 
//│ let* (x2) = mktup2(1,2)
//│   in x2
//│ )
//│ },
//│ let* (x3) = foo()
//│   in x3)

:GraphOpt
class Pair(x, y)
fun foo(pair) =
  if pair is
    Pair(x, y) then Pair(x, y)
fun bar() =
  foo(Pair(1, 2))
bar()
//│ |#class| |Pair|(|x|,| |y|)|↵|#fun| |foo|(|pair|)| |#=|→|#if| |pair| |is|→|Pair|(|x|,| |y|)| |#then| |Pair|(|x|,| |y|)|←|←|↵|#fun| |bar|(||)| |#=|→|foo|(|Pair|(|1|,| |2|)|)|←|↵|bar|(||)|
//│ Parsed: {class Pair(x, y,) {}; fun foo = (pair,) => {if pair is ‹(Pair(x, y,)) then Pair(x, y,)›}; fun bar = () => {foo(Pair(1, 2,),)}; bar()}
//│ Parsed:
//│ TypingUnit(NuTypeDef(class, Pair, (), Tup(_: Var(x), _: Var(y)), (), None, None, TypingUnit()), NuFunDef(None, foo, None, [], Lam(Tup(_: Var(pair)), Blk(...))), NuFunDef(None, bar, None, [], Lam(Tup(), Blk(...))), App(Var(bar), Tup()))
//│ 
//│ GraphOpt:
//│ GOProgram({ClassInfo(0, Pair, [x,y])}, {
//│ Def(0, foo, [pair], [{}], 
//│ None, 1, 
//│ let join j0(x4) = x4
//│   in case pair of
//│     Pair => let x1 = pair.y
//│       in let x2 = pair.x
//│         in let x3 = Pair(x2,x1)
//│           in jump j0(x3)
//│ )
//│ Def(1, bar, [], [{}], 
//│ None, 1, 
//│ let x5 = Pair(1,2)
//│   in let* (x6) = foo(x5)
//│     in x6
//│ )
//│ },
//│ let* (x7) = bar()
//│   in x7)
//│ 
//│ Promoted ------------------------------------
//│ GOProgram({ClassInfo(0, Pair, [x,y])}, {
//│ Def(0, foo, [pair], [{EDestruct，EDirect，ESelect(y)，ESelect(x)}], 
//│ Some(ICtor(Pair)), 1, 
//│ case pair of
//│   Pair => let x1 = pair.y
//│     in let x2 = pair.x
//│       in let x3 = Pair(x2,x1)
//│         in x3
//│ )
//│ Def(1, bar, [], [], 
//│ Some(ICtor(Pair)), 1, 
//│ let x5 = Pair(1,2)
//│   in let* (x6) = foo(x5)
//│     in x6
//│ )
//│ },
//│ let* (x7) = bar()
//│   in x7)
//│ 
//│ Optimized ------------------------------
//│ GOProgram({ClassInfo(0, Pair, [x,y])}, {
//│ Def(1, bar, [], [], 
//│ Some(ICtor(Pair)), 1, 
//│ let* (x6) = foo$D9$S11(2,1)
//│   in x6
//│ )
//│ Def(5, foo$D9$S11, [pair_y,pair_x], [{EDirect},{EDirect}], 
//│ Some(ICtor(Pair)), 1, 
//│ let x3 = Pair(pair_x,pair_y)
//│   in x3
//│ )
//│ },
//│ let* (x7) = bar()
//│   in x7)


:GraphOpt
fun add3(x) = y => z => x + y + z
fun foo(f) = f(2)
foo(add3(1))
//│ |#fun| |add3|(|x|)| |#=| |y| |#=>| |z| |#=>| |x| |+| |y| |+| |z|↵|#fun| |foo|(|f|)| |#=| |f|(|2|)|↵|foo|(|add3|(|1|)|)|
//│ Parsed: {fun add3 = (x,) => (y,) => (z,) => +(+(x,)(y,),)(z,); fun foo = (f,) => f(2,); foo(add3(1,),)}
//│ Parsed:
//│ TypingUnit(NuFunDef(None, add3, None, [], Lam(Tup(_: Var(x)), Lam(Tup(_: Var(y)), Lam(Tup(_: Var(z)), App(App(Var(+), Tup(_: App(App(Var(+), Tup(_: Var(x))), Tup(_: Var(y))))), Tup(_: Var(z))))))), NuFunDef(None, foo, None, [], Lam(Tup(_: Var(f)), App(Var(f), Tup(_: IntLit(2))))), App(Var(foo), Tup(_: App(Var(add3), Tup(_: IntLit(1))))))
//│ 
//│ GraphOpt:
//│ GOProgram({}, {
//│ Def(0, add3, [x], [{}], 
//│ None, 1, 
//│ let x0 = y => let x1 = z => let x2 = +(x,y)
//│   in let x3 = +(x2,z)
//│     in x3
//│   in x1
//│   in x0
//│ )
//│ Def(1, foo, [f], [{}], 
//│ None, 1, 
//│ let x4 = f(2)
//│   in x4
//│ )
//│ },
//│ let* (x5) = add3(1)
//│   in let* (x6) = foo(x5)
//│     in x6)
//│ 
//│ Promoted ------------------------------------
//│ GOProgram({}, {
//│ Def(0, add3, [x], [{EDirect}], 
//│ Some(ILam(1)), 1, 
//│ let x0 = y => let x1 = z => let x2 = +(x,y)
//│   in let x3 = +(x2,z)
//│     in x3
//│   in x1
//│   in x0
//│ )
//│ Def(1, foo, [f], [{EApp(1)}], 
//│ None, 1, 
//│ let x4 = f(2)
//│   in x4
//│ )
//│ },
//│ let* (x5) = add3(1)
//│   in let* (x6) = foo(x5)
//│     in x6)

:GraphOpt
class Pair(x, y) {}
fun silly(pair) =
  let _ = 0
  let n = if pair is
    Pair(x1, x2) then
      if pair is
        Pair (x3, x4) then x3 + 1
  n + 1
fun foo() =
    let a = Pair(0, 1)
    let b = silly(a)
    b
foo()
//│ |#class| |Pair|(|x|,| |y|)| |{||}|↵|#fun| |silly|(|pair|)| |#=|→|#let| |_| |#=| |0|↵|#let| |n| |#=| |#if| |pair| |is|→|Pair|(|x1|,| |x2|)| |#then|→|#if| |pair| |is|→|Pair| |(|x3|,| |x4|)| |#then| |x3| |+| |1|←|←|←|↵|n| |+| |1|←|↵|#fun| |foo|(||)| |#=|→|#let| |a| |#=| |Pair|(|0|,| |1|)|↵|#let| |b| |#=| |silly|(|a|)|↵|b|←|↵|foo|(||)|
//│ Parsed: {class Pair(x, y,) {}; fun silly = (pair,) => {let _ = 0; let n = if pair is ‹(Pair(x1, x2,)) then {if pair is ‹(Pair(x3, x4,)) then +(x3,)(1,)›}›; +(n,)(1,)}; fun foo = () => {let a = Pair(0, 1,); let b = silly(a,); b}; foo()}
//│ Parsed:
//│ TypingUnit(NuTypeDef(class, Pair, (), Tup(_: Var(x), _: Var(y)), (), None, None, TypingUnit()), NuFunDef(None, silly, None, [], Lam(Tup(_: Var(pair)), Blk(...))), NuFunDef(None, foo, None, [], Lam(Tup(), Blk(...))), App(Var(foo), Tup()))
//│ 
//│ GraphOpt:
//│ GOProgram({ClassInfo(0, Pair, [x,y])}, {
//│ Def(0, silly, [pair], [{}], 
//│ None, 1, 
//│ let x0 = 0
//│   in let join j1(x9) = let x10 = +(x9,1)
//│         in x10
//│     in case pair of
//│       Pair => let x2 = pair.y
//│         in let x3 = pair.x
//│           in let join j4(x8) = jump j1(x8)
//│             in case pair of
//│               Pair => let x5 = pair.y
//│                 in let x6 = pair.x
//│                   in let x7 = +(x6,1)
//│                     in jump j4(x7)
//│ )
//│ Def(1, foo, [], [{}], 
//│ None, 1, 
//│ let x11 = Pair(0,1)
//│   in let* (x12) = silly(x11)
//│     in x12
//│ )
//│ },
//│ let* (x13) = foo()
//│   in x13)
//│ 
//│ Promoted ------------------------------------
//│ GOProgram({ClassInfo(0, Pair, [x,y])}, {
//│ Def(0, silly, [pair], [{EDestruct，EDirect，ESelect(x)}], 
//│ None, 1, 
//│ case pair of
//│   Pair => case pair of
//│     Pair => let x6 = pair.x
//│       in let x7 = +(x6,1)
//│         in jump j4(x7)
//│ )
//│ Def(1, foo, [], [], 
//│ None, 1, 
//│ let x11 = Pair(0,1)
//│   in let* (x12) = silly(x11)
//│     in x12
//│ )
//│ Def(2, @join j1, [x9], [{EDirect}], 
//│ None, 1, 
//│ let x10 = +(x9,1)
//│   in x10
//│ )
//│ Def(3, @join j4, [x8], [{EDirect}], 
//│ None, 1, 
//│ jump j1(x8)
//│ )
//│ },
//│ let* (x13) = foo()
//│   in x13)
//│ 
//│ Optimized ------------------------------
//│ GOProgram({ClassInfo(0, Pair, [x,y])}, {
//│ Def(1, foo, [], [], 
//│ None, 1, 
//│ let x11 = Pair(0,1)
//│   in let* (x12) = silly$D15(x11)
//│     in x12
//│ )
//│ Def(2, @join j1, [x9], [{EDirect}], 
//│ None, 1, 
//│ let x10 = +(x9,1)
//│   in x10
//│ )
//│ Def(3, @join j4, [x8], [{EDirect}], 
//│ None, 1, 
//│ jump j1(x8)
//│ )
//│ Def(5, silly$D15, [pair], [{EDestruct，EDirect，ESelect(x)}], 
//│ None, 1, 
//│ case pair of
//│   Pair => let x6 = pair.x
//│     in let x7 = +(x6,1)
//│       in jump j4(x7)
//│ )
//│ },
//│ let* (x13) = foo()
//│   in x13)
//│ 
//│ Optimized ------------------------------
//│ GOProgram({ClassInfo(0, Pair, [x,y])}, {
//│ Def(1, foo, [], [], 
//│ None, 1, 
//│ let* (x12) = silly$D15$D18$S20(0)
//│   in x12
//│ )
//│ Def(2, @join j1, [x9], [{EDirect}], 
//│ None, 1, 
//│ let x10 = +(x9,1)
//│   in x10
//│ )
//│ Def(3, @join j4, [x8], [{EDirect}], 
//│ None, 1, 
//│ jump j1(x8)
//│ )
//│ Def(8, silly$D15$D18$S20, [pair_x], [{EDirect}], 
//│ None, 1, 
//│ let x7 = +(pair_x,1)
//│   in jump j4(x7)
//│ )
//│ },
//│ let* (x13) = foo()
//│   in x13)

:GraphOpt
class A(x, y, z)
class B(m, n)
fun complex_foo(t) =
  let r = if t is 
    A(x, y, z) then x + y * z
    B(m, n) then m - n
  let s = B(1, 2)
  let u = if s is
    A(x, y, z) then 3 
    B(m, n) then 4
  r + u
fun bar() =
  complex_foo(A(6, 7, 8))
  complex_foo(B(9, 10))
bar()
//│ |#class| |A|(|x|,| |y|,| |z|)|↵|#class| |B|(|m|,| |n|)|↵|#fun| |complex_foo|(|t|)| |#=|→|#let| |r| |#=| |#if| |t| |is| |→|A|(|x|,| |y|,| |z|)| |#then| |x| |+| |y| |*| |z|↵|B|(|m|,| |n|)| |#then| |m| |-| |n|←|↵|#let| |s| |#=| |B|(|1|,| |2|)|↵|#let| |u| |#=| |#if| |s| |is|→|A|(|x|,| |y|,| |z|)| |#then| |3| |↵|B|(|m|,| |n|)| |#then| |4|←|↵|r| |+| |u|←|↵|#fun| |bar|(||)| |#=|→|complex_foo|(|A|(|6|,| |7|,| |8|)|)|↵|complex_foo|(|B|(|9|,| |10|)|)|←|↵|bar|(||)|
//│ Parsed: {class A(x, y, z,) {}; class B(m, n,) {}; fun complex_foo = (t,) => {let r = if t is ‹(A(x, y, z,)) then +(x,)(*(y,)(z,),); (B(m, n,)) then -(m,)(n,)›; let s = B(1, 2,); let u = if s is ‹(A(x, y, z,)) then 3; (B(m, n,)) then 4›; +(r,)(u,)}; fun bar = () => {complex_foo(A(6, 7, 8,),); complex_foo(B(9, 10,),)}; bar()}
//│ Parsed:
//│ TypingUnit(NuTypeDef(class, A, (), Tup(_: Var(x), _: Var(y), _: Var(z)), (), None, None, TypingUnit()), NuTypeDef(class, B, (), Tup(_: Var(m), _: Var(n)), (), None, None, TypingUnit()), NuFunDef(None, complex_foo, None, [], Lam(Tup(_: Var(t)), Blk(...))), NuFunDef(None, bar, None, [], Lam(Tup(), Blk(...))), App(Var(bar), Tup()))
//│ 
//│ GraphOpt:
//│ GOProgram({ClassInfo(0, A, [x,y,z]),ClassInfo(1, B, [m,n])}, {
//│ Def(0, complex_foo, [t], [{}], 
//│ None, 1, 
//│ let join j0(x9) = let x10 = B(1,2)
//│       in let join j11(x17) = let x18 = +(x9,x17)
//│             in x18
//│         in case x10 of
//│           A => let x12 = x10.z
//│             in let x13 = x10.y
//│               in let x14 = x10.x
//│                 in jump j11(3)
//│           B => let x15 = x10.n
//│             in let x16 = x10.m
//│               in jump j11(4)
//│   in case t of
//│     A => let x1 = t.z
//│       in let x2 = t.y
//│         in let x3 = t.x
//│           in let x4 = *(x2,x1)
//│             in let x5 = +(x3,x4)
//│               in jump j0(x5)
//│     B => let x6 = t.n
//│       in let x7 = t.m
//│         in let x8 = -(x7,x6)
//│           in jump j0(x8)
//│ )
//│ Def(1, bar, [], [{}], 
//│ None, 1, 
//│ let x19 = A(6,7,8)
//│   in let* (x20) = complex_foo(x19)
//│     in let x21 = B(9,10)
//│       in let* (x22) = complex_foo(x21)
//│         in x22
//│ )
//│ },
//│ let* (x23) = bar()
//│   in x23)
//│ 
//│ Promoted ------------------------------------
//│ GOProgram({ClassInfo(0, A, [x,y,z]),ClassInfo(1, B, [m,n])}, {
//│ Def(0, complex_foo, [t], [{ESelect(m)，ESelect(y)，ESelect(n)，ESelect(z)，ESelect(x)，EDirect，EDestruct}], 
//│ None, 1, 
//│ case t of
//│   A => let x1 = t.z
//│     in let x2 = t.y
//│       in let x3 = t.x
//│         in let x4 = *(x2,x1)
//│           in let x5 = +(x3,x4)
//│             in jump j0(x5)
//│   B => let x6 = t.n
//│     in let x7 = t.m
//│       in let x8 = -(x7,x6)
//│         in jump j0(x8)
//│ )
//│ Def(1, bar, [], [], 
//│ None, 1, 
//│ let x19 = A(6,7,8)
//│   in let* (x20) = complex_foo(x19)
//│     in let x21 = B(9,10)
//│       in let* (x22) = complex_foo(x21)
//│         in x22
//│ )
//│ Def(2, @join j0, [x9], [{EDirect}], 
//│ None, 1, 
//│ let x10 = B(1,2)
//│   in case x10 of
//│     A => jump j11(3)
//│     B => jump j11(4)
//│ )
//│ Def(3, @join j11, [x17], [{EDirect}], 
//│ None, 1, 
//│ let x18 = +(x9,x17)
//│   in x18
//│ )
//│ },
//│ let* (x23) = bar()
//│   in x23)
//│ 
//│ Optimized ------------------------------
//│ GOProgram({ClassInfo(0, A, [x,y,z]),ClassInfo(1, B, [m,n])}, {
//│ Def(1, bar, [], [], 
//│ None, 1, 
//│ let* (x20) = complex_foo$D25$S29(8,7,6)
//│   in let* (x22) = complex_foo$D26$S30(10,9)
//│     in x22
//│ )
//│ Def(2, @join j0, [x9], [{EDirect}], 
//│ None, 1, 
//│ let x10 = B(1,2)
//│   in case x10 of
//│     A => jump j11(3)
//│     B => jump j11(4)
//│ )
//│ Def(3, @join j11, [x17], [{EDirect}], 
//│ None, 1, 
//│ let x18 = +(x9,x17)
//│   in x18
//│ )
//│ Def(7, complex_foo$D25$S29, [t_z,t_y,t_x], [{EDirect},{EDirect},{EDirect}], 
//│ None, 1, 
//│ let x4 = *(t_y,t_z)
//│   in let x5 = +(t_x,x4)
//│     in jump j0(x5)
//│ )
//│ Def(8, complex_foo$D26$S30, [t_n,t_m], [{EDirect},{EDirect}], 
//│ None, 1, 
//│ let x8 = -(t_m,t_n)
//│   in jump j0(x8)
//│ )
//│ },
//│ let* (x23) = bar()
//│   in x23)

:GraphOpt
class A(w, x)
class B(y)
class C(z)
fun complex_foo(t) =
  let a = 1 + 2
  let b = 1 * 2
  let x = if t is
    A(x, y) then y 
    B(x) then B(x + b)
    C(x) then C(0)
  let z = A(5, x)
  let v = B(6)
  let y = if x is
    A(x, y) then
      let m = x + a + b
      if y is
        A(x, y) then x
        B(x) then m
        C(x) then 0
    B(x) then 2
    C(x) then 3
  if z is
    A(x, y) then x
    B(x) then 4
    C(x) then
      if v is
        A(x, y) then x
        B(x) then 7
        C(x) then 8
fun bar() =
  complex_foo(A(10, A(9, B(10))))
bar()
//│ |#class| |A|(|w|,| |x|)|↵|#class| |B|(|y|)|↵|#class| |C|(|z|)|↵|#fun| |complex_foo|(|t|)| |#=|→|#let| |a| |#=| |1| |+| |2|↵|#let| |b| |#=| |1| |*| |2|↵|#let| |x| |#=| |#if| |t| |is|→|A|(|x|,| |y|)| |#then| |y| |↵|B|(|x|)| |#then| |B|(|x| |+| |b|)|↵|C|(|x|)| |#then| |C|(|0|)|←|↵|#let| |z| |#=| |A|(|5|,| |x|)|↵|#let| |v| |#=| |B|(|6|)|↵|#let| |y| |#=| |#if| |x| |is|→|A|(|x|,| |y|)| |#then|→|#let| |m| |#=| |x| |+| |a| |+| |b|↵|#if| |y| |is|→|A|(|x|,| |y|)| |#then| |x|↵|B|(|x|)| |#then| |m|↵|C|(|x|)| |#then| |0|←|←|↵|B|(|x|)| |#then| |2|↵|C|(|x|)| |#then| |3|←|↵|#if| |z| |is|→|A|(|x|,| |y|)| |#then| |x|↵|B|(|x|)| |#then| |4|↵|C|(|x|)| |#then|→|#if| |v| |is|→|A|(|x|,| |y|)| |#then| |x|↵|B|(|x|)| |#then| |7|↵|C|(|x|)| |#then| |8|←|←|←|←|↵|#fun| |bar|(||)| |#=|→|complex_foo|(|A|(|10|,| |A|(|9|,| |B|(|10|)|)|)|)|←|↵|bar|(||)|
//│ Parsed: {class A(w, x,) {}; class B(y,) {}; class C(z,) {}; fun complex_foo = (t,) => {let a = +(1,)(2,); let b = *(1,)(2,); let x = if t is ‹(A(x, y,)) then y; (B(x,)) then B(+(x,)(b,),); (C(x,)) then C(0,)›; let z = A(5, x,); let v = B(6,); let y = if x is ‹(A(x, y,)) then {let m = +(+(x,)(a,),)(b,); if y is ‹(A(x, y,)) then x; (B(x,)) then m; (C(x,)) then 0›}; (B(x,)) then 2; (C(x,)) then 3›; if z is ‹(A(x, y,)) then x; (B(x,)) then 4; (C(x,)) then {if v is ‹(A(x, y,)) then x; (B(x,)) then 7; (C(x,)) then 8›}›}; fun bar = () => {complex_foo(A(10, A(9, B(10,),),),)}; bar()}
//│ Parsed:
//│ TypingUnit(NuTypeDef(class, A, (), Tup(_: Var(w), _: Var(x)), (), None, None, TypingUnit()), NuTypeDef(class, B, (), Tup(_: Var(y)), (), None, None, TypingUnit()), NuTypeDef(class, C, (), Tup(_: Var(z)), (), None, None, TypingUnit()), NuFunDef(None, complex_foo, None, [], Lam(Tup(_: Var(t)), Blk(...))), NuFunDef(None, bar, None, [], Lam(Tup(), Blk(...))), App(Var(bar), Tup()))
//│ 
//│ GraphOpt:
//│ GOProgram({ClassInfo(0, A, [w,x]),ClassInfo(1, B, [y]),ClassInfo(2, C, [z])}, {
//│ Def(0, complex_foo, [t], [{}], 
//│ None, 1, 
//│ let x0 = +(1,2)
//│   in let x1 = *(1,2)
//│     in let join j2(x10) = let x11 = A(5,x10)
//│           in let x12 = B(6)
//│             in let join j13(x26) = let join j27(x38) = x38
//│                   in case x11 of
//│                     A => let x28 = x11.x
//│                       in let x29 = x11.w
//│                         in jump j27(x29)
//│                     B => let x30 = x11.y
//│                       in jump j27(4)
//│                     C => let x31 = x11.z
//│                       in let join j32(x37) = jump j27(x37)
//│                         in case x12 of
//│                           A => let x33 = x12.x
//│                             in let x34 = x12.w
//│                               in jump j32(x34)
//│                           B => let x35 = x12.y
//│                             in jump j32(7)
//│                           C => let x36 = x12.z
//│                             in jump j32(8)
//│               in case x10 of
//│                 A => let x14 = x10.x
//│                   in let x15 = x10.w
//│                     in let x16 = +(x15,x0)
//│                       in let x17 = +(x16,x1)
//│                         in let join j18(x23) = jump j13(x23)
//│                           in case x14 of
//│                             A => let x19 = x14.x
//│                               in let x20 = x14.w
//│                                 in jump j18(x20)
//│                             B => let x21 = x14.y
//│                               in jump j18(x17)
//│                             C => let x22 = x14.z
//│                               in jump j18(0)
//│                 B => let x24 = x10.y
//│                   in jump j13(2)
//│                 C => let x25 = x10.z
//│                   in jump j13(3)
//│       in case t of
//│         A => let x3 = t.x
//│           in let x4 = t.w
//│             in jump j2(x3)
//│         B => let x5 = t.y
//│           in let x6 = +(x5,x1)
//│             in let x7 = B(x6)
//│               in jump j2(x7)
//│         C => let x8 = t.z
//│           in let x9 = C(0)
//│             in jump j2(x9)
//│ )
//│ Def(1, bar, [], [{}], 
//│ None, 1, 
//│ let x39 = B(10)
//│   in let x40 = A(9,x39)
//│     in let x41 = A(10,x40)
//│       in let* (x42) = complex_foo(x41)
//│         in x42
//│ )
//│ },
//│ let* (x43) = bar()
//│   in x43)
//│ 
//│ Promoted ------------------------------------
//│ GOProgram({ClassInfo(0, A, [w,x]),ClassInfo(1, B, [y]),ClassInfo(2, C, [z])}, {
//│ Def(0, complex_foo, [t], [{EDestruct，EDirect，ESelect(x)，ESelect(y)}], 
//│ None, 1, 
//│ let x0 = +(1,2)
//│   in let x1 = *(1,2)
//│     in case t of
//│       A => let x3 = t.x
//│         in jump j2(x3)
//│       B => let x5 = t.y
//│         in let x6 = +(x5,x1)
//│           in let x7 = B(x6)
//│             in jump j2(x7)
//│       C => let x9 = C(0)
//│         in jump j2(x9)
//│ )
//│ Def(1, bar, [], [], 
//│ None, 1, 
//│ let x39 = B(10)
//│   in let x40 = A(9,x39)
//│     in let x41 = A(10,x40)
//│       in let* (x42) = complex_foo(x41)
//│         in x42
//│ )
//│ Def(2, @join j2, [x10], [{EDirect，EDestruct，ESelect(x)，ESelect(w)}], 
//│ None, 1, 
//│ let x11 = A(5,x10)
//│   in let x12 = B(6)
//│     in case x10 of
//│       A => let x14 = x10.x
//│         in let x15 = x10.w
//│           in let x16 = +(x15,x0)
//│             in let x17 = +(x16,x1)
//│               in case x14 of
//│                 A => let x20 = x14.w
//│                   in jump j18(x20)
//│                 B => jump j18(x17)
//│                 C => jump j18(0)
//│       B => jump j13(2)
//│       C => jump j13(3)
//│ )
//│ Def(3, @join j13, [x26], [{}], 
//│ None, 1, 
//│ case x11 of
//│   A => let x29 = x11.w
//│     in x29
//│   B => 4
//│   C => case x12 of
//│     A => let x34 = x12.w
//│       in x34
//│     B => 7
//│     C => 8
//│ )
//│ Def(6, @join j18, [x23], [{EDirect}], 
//│ None, 1, 
//│ jump j13(x23)
//│ )
//│ },
//│ let* (x43) = bar()
//│   in x43)
//│ 
//│ Optimized ------------------------------
//│ GOProgram({ClassInfo(0, A, [w,x]),ClassInfo(1, B, [y]),ClassInfo(2, C, [z])}, {
//│ Def(1, bar, [], [], 
//│ None, 1, 
//│ let x39 = B(10)
//│   in let x40 = A(9,x39)
//│     in let x41 = A(10,x40)
//│       in let* (x62,x63,x64) = complex_foo$P44(x41)
//│         in let* (x42) = complex_foo$D45(x62,x63,x64)
//│           in x42
//│ )
//│ Def(2, @join j2, [x10], [{EDirect，EDestruct，ESelect(x)，ESelect(w)}], 
//│ None, 1, 
//│ let x11 = A(5,x10)
//│   in let x12 = B(6)
//│     in case x10 of
//│       A => let x14 = x10.x
//│         in let x15 = x10.w
//│           in let x16 = +(x15,x0)
//│             in let x17 = +(x16,x1)
//│               in case x14 of
//│                 A => let x20 = x14.w
//│                   in jump j18(x20)
//│                 B => jump j18(x17)
//│                 C => jump j18(0)
//│       B => jump j13(2)
//│       C => jump j13(3)
//│ )
//│ Def(3, @join j13, [x26], [{}], 
//│ None, 1, 
//│ case x11 of
//│   A => let x29 = x11.w
//│     in x29
//│   B => 4
//│   C => case x12 of
//│     A => let x34 = x12.w
//│       in x34
//│     B => 7
//│     C => 8
//│ )
//│ Def(6, @join j18, [x23], [{EDirect}], 
//│ None, 1, 
//│ jump j13(x23)
//│ )
//│ Def(7, complex_foo$P44, [t], [{EDirect}], 
//│ None, 3, 
//│ let x0 = +(1,2)
//│   in let x1 = *(1,2)
//│     in t,x0,x1
//│ )
//│ Def(8, complex_foo$D45, [t,x0,x1], [{ESelect(x)},{EDirect},{EDirect}], 
//│ None, 1, 
//│ let x3 = t.x
//│   in jump j2(x3)
//│ )
//│ },
//│ let* (x43) = bar()
//│   in x43)

:GraphOpt
class A(w, x)
class B(y)
class C(z)
fun complex_foo(t) =
  let a = 1 + 2
  let b = 1 * 2
  let x = if t is
    A(x, y) then A(x, C(0))
    B(x) then B(x + b)
    C(x) then C(0)
  let z = A(5, x)
  let v = B(6)
  let y = if x is
    A(x, y) then
      let m = x + a + b
      if y is
        A(x, y) then x
        B(x) then m
        C(x) then 0
    B(x) then 2
    C(x) then 3
  if z is
    A(x, y) then x
    B(x) then 4
    C(x) then
      if v is
        A(x, y) then x
        B(x) then 7
        C(x) then 8
fun bar() =
  complex_foo(A(10, A(9, B(10))))
bar()
//│ |#class| |A|(|w|,| |x|)|↵|#class| |B|(|y|)|↵|#class| |C|(|z|)|↵|#fun| |complex_foo|(|t|)| |#=|→|#let| |a| |#=| |1| |+| |2|↵|#let| |b| |#=| |1| |*| |2|↵|#let| |x| |#=| |#if| |t| |is|→|A|(|x|,| |y|)| |#then| |A|(|x|,| |C|(|0|)|)|↵|B|(|x|)| |#then| |B|(|x| |+| |b|)|↵|C|(|x|)| |#then| |C|(|0|)|←|↵|#let| |z| |#=| |A|(|5|,| |x|)|↵|#let| |v| |#=| |B|(|6|)|↵|#let| |y| |#=| |#if| |x| |is|→|A|(|x|,| |y|)| |#then|→|#let| |m| |#=| |x| |+| |a| |+| |b|↵|#if| |y| |is|→|A|(|x|,| |y|)| |#then| |x|↵|B|(|x|)| |#then| |m|↵|C|(|x|)| |#then| |0|←|←|↵|B|(|x|)| |#then| |2|↵|C|(|x|)| |#then| |3|←|↵|#if| |z| |is|→|A|(|x|,| |y|)| |#then| |x|↵|B|(|x|)| |#then| |4|↵|C|(|x|)| |#then|→|#if| |v| |is|→|A|(|x|,| |y|)| |#then| |x|↵|B|(|x|)| |#then| |7|↵|C|(|x|)| |#then| |8|←|←|←|←|↵|#fun| |bar|(||)| |#=|→|complex_foo|(|A|(|10|,| |A|(|9|,| |B|(|10|)|)|)|)|←|↵|bar|(||)|
//│ Parsed: {class A(w, x,) {}; class B(y,) {}; class C(z,) {}; fun complex_foo = (t,) => {let a = +(1,)(2,); let b = *(1,)(2,); let x = if t is ‹(A(x, y,)) then A(x, C(0,),); (B(x,)) then B(+(x,)(b,),); (C(x,)) then C(0,)›; let z = A(5, x,); let v = B(6,); let y = if x is ‹(A(x, y,)) then {let m = +(+(x,)(a,),)(b,); if y is ‹(A(x, y,)) then x; (B(x,)) then m; (C(x,)) then 0›}; (B(x,)) then 2; (C(x,)) then 3›; if z is ‹(A(x, y,)) then x; (B(x,)) then 4; (C(x,)) then {if v is ‹(A(x, y,)) then x; (B(x,)) then 7; (C(x,)) then 8›}›}; fun bar = () => {complex_foo(A(10, A(9, B(10,),),),)}; bar()}
//│ Parsed:
//│ TypingUnit(NuTypeDef(class, A, (), Tup(_: Var(w), _: Var(x)), (), None, None, TypingUnit()), NuTypeDef(class, B, (), Tup(_: Var(y)), (), None, None, TypingUnit()), NuTypeDef(class, C, (), Tup(_: Var(z)), (), None, None, TypingUnit()), NuFunDef(None, complex_foo, None, [], Lam(Tup(_: Var(t)), Blk(...))), NuFunDef(None, bar, None, [], Lam(Tup(), Blk(...))), App(Var(bar), Tup()))
//│ 
//│ GraphOpt:
//│ GOProgram({ClassInfo(0, A, [w,x]),ClassInfo(1, B, [y]),ClassInfo(2, C, [z])}, {
//│ Def(0, complex_foo, [t], [{}], 
//│ None, 1, 
//│ let x0 = +(1,2)
//│   in let x1 = *(1,2)
//│     in let join j2(x12) = let x13 = A(5,x12)
//│           in let x14 = B(6)
//│             in let join j15(x28) = let join j29(x40) = x40
//│                   in case x13 of
//│                     A => let x30 = x13.x
//│                       in let x31 = x13.w
//│                         in jump j29(x31)
//│                     B => let x32 = x13.y
//│                       in jump j29(4)
//│                     C => let x33 = x13.z
//│                       in let join j34(x39) = jump j29(x39)
//│                         in case x14 of
//│                           A => let x35 = x14.x
//│                             in let x36 = x14.w
//│                               in jump j34(x36)
//│                           B => let x37 = x14.y
//│                             in jump j34(7)
//│                           C => let x38 = x14.z
//│                             in jump j34(8)
//│               in case x12 of
//│                 A => let x16 = x12.x
//│                   in let x17 = x12.w
//│                     in let x18 = +(x17,x0)
//│                       in let x19 = +(x18,x1)
//│                         in let join j20(x25) = jump j15(x25)
//│                           in case x16 of
//│                             A => let x21 = x16.x
//│                               in let x22 = x16.w
//│                                 in jump j20(x22)
//│                             B => let x23 = x16.y
//│                               in jump j20(x19)
//│                             C => let x24 = x16.z
//│                               in jump j20(0)
//│                 B => let x26 = x12.y
//│                   in jump j15(2)
//│                 C => let x27 = x12.z
//│                   in jump j15(3)
//│       in case t of
//│         A => let x3 = t.x
//│           in let x4 = t.w
//│             in let x5 = C(0)
//│               in let x6 = A(x4,x5)
//│                 in jump j2(x6)
//│         B => let x7 = t.y
//│           in let x8 = +(x7,x1)
//│             in let x9 = B(x8)
//│               in jump j2(x9)
//│         C => let x10 = t.z
//│           in let x11 = C(0)
//│             in jump j2(x11)
//│ )
//│ Def(1, bar, [], [{}], 
//│ None, 1, 
//│ let x41 = B(10)
//│   in let x42 = A(9,x41)
//│     in let x43 = A(10,x42)
//│       in let* (x44) = complex_foo(x43)
//│         in x44
//│ )
//│ },
//│ let* (x45) = bar()
//│   in x45)
//│ 
//│ Promoted ------------------------------------
//│ GOProgram({ClassInfo(0, A, [w,x]),ClassInfo(1, B, [y]),ClassInfo(2, C, [z])}, {
//│ Def(0, complex_foo, [t], [{EDestruct，EDirect，ESelect(w)，ESelect(y)}], 
//│ None, 1, 
//│ let x0 = +(1,2)
//│   in let x1 = *(1,2)
//│     in case t of
//│       A => let x4 = t.w
//│         in let x5 = C(0)
//│           in let x6 = A(x4,x5)
//│             in jump j2(x6)
//│       B => let x7 = t.y
//│         in let x8 = +(x7,x1)
//│           in let x9 = B(x8)
//│             in jump j2(x9)
//│       C => let x11 = C(0)
//│         in jump j2(x11)
//│ )
//│ Def(1, bar, [], [], 
//│ None, 1, 
//│ let x41 = B(10)
//│   in let x42 = A(9,x41)
//│     in let x43 = A(10,x42)
//│       in let* (x44) = complex_foo(x43)
//│         in x44
//│ )
//│ Def(2, @join j2, [x12], [{EDirect，EDestruct，ESelect(x)，ESelect(w)}], 
//│ None, 1, 
//│ let x13 = A(5,x12)
//│   in let x14 = B(6)
//│     in case x12 of
//│       A => let x16 = x12.x
//│         in let x17 = x12.w
//│           in let x18 = +(x17,x0)
//│             in let x19 = +(x18,x1)
//│               in case x16 of
//│                 A => let x22 = x16.w
//│                   in jump j20(x22)
//│                 B => jump j20(x19)
//│                 C => jump j20(0)
//│       B => jump j15(2)
//│       C => jump j15(3)
//│ )
//│ Def(3, @join j15, [x28], [{}], 
//│ None, 1, 
//│ case x13 of
//│   A => let x31 = x13.w
//│     in x31
//│   B => 4
//│   C => case x14 of
//│     A => let x36 = x14.w
//│       in x36
//│     B => 7
//│     C => 8
//│ )
//│ Def(6, @join j20, [x25], [{EDirect}], 
//│ None, 1, 
//│ jump j15(x25)
//│ )
//│ },
//│ let* (x45) = bar()
//│   in x45)
//│ 
//│ Optimized ------------------------------
//│ GOProgram({ClassInfo(0, A, [w,x]),ClassInfo(1, B, [y]),ClassInfo(2, C, [z])}, {
//│ Def(1, bar, [], [], 
//│ None, 1, 
//│ let x41 = B(10)
//│   in let x42 = A(9,x41)
//│     in let x43 = A(10,x42)
//│       in let* (x69,x70,x71) = complex_foo$P46(x43)
//│         in let* (x44) = complex_foo$D47(x69,x70,x71)
//│           in x44
//│ )
//│ Def(2, @join j2, [x12], [{EDirect，EDestruct，ESelect(x)，ESelect(w)}], 
//│ None, 1, 
//│ let x13 = A(5,x12)
//│   in let x14 = B(6)
//│     in case x12 of
//│       A => let x16 = x12.x
//│         in let x17 = x12.w
//│           in let x18 = +(x17,x0)
//│             in let x19 = +(x18,x1)
//│               in case x16 of
//│                 A => let x22 = x16.w
//│                   in jump j20(x22)
//│                 B => jump j20(x19)
//│                 C => jump j20(0)
//│       B => jump j15(2)
//│       C => jump j15(3)
//│ )
//│ Def(3, @join j15, [x28], [{}], 
//│ None, 1, 
//│ case x13 of
//│   A => let x31 = x13.w
//│     in x31
//│   B => 4
//│   C => case x14 of
//│     A => let x36 = x14.w
//│       in x36
//│     B => 7
//│     C => 8
//│ )
//│ Def(6, @join j20, [x25], [{EDirect}], 
//│ None, 1, 
//│ jump j15(x25)
//│ )
//│ Def(7, complex_foo$P46, [t], [{EDirect}], 
//│ None, 3, 
//│ let x0 = +(1,2)
//│   in let x1 = *(1,2)
//│     in t,x0,x1
//│ )
//│ Def(8, complex_foo$D47, [t,x0,x1], [{ESelect(w)},{EDirect},{EDirect}], 
//│ None, 1, 
//│ let x4 = t.w
//│   in let x5 = C(0)
//│     in let x6 = A(x4,x5)
//│       in jump j2(x6)
//│ )
//│ },
//│ let* (x45) = bar()
//│   in x45)
//│ 
//│ Optimized ------------------------------
//│ GOProgram({ClassInfo(0, A, [w,x]),ClassInfo(1, B, [y]),ClassInfo(2, C, [z])}, {
//│ Def(1, bar, [], [], 
//│ None, 1, 
//│ let x41 = B(10)
//│   in let x42 = A(9,x41)
//│     in let x43 = A(10,x42)
//│       in let* (x69,x70,x71) = complex_foo$P46(x43)
//│         in let* (x44) = complex_foo$D47(x69,x70,x71)
//│           in x44
//│ )
//│ Def(3, @join j15, [x28], [{}], 
//│ None, 1, 
//│ case x13 of
//│   A => let x31 = x13.w
//│     in x31
//│   B => 4
//│   C => case x14 of
//│     A => let x36 = x14.w
//│       in x36
//│     B => 7
//│     C => 8
//│ )
//│ Def(6, @join j20, [x25], [{EDirect}], 
//│ None, 1, 
//│ jump j15(x25)
//│ )
//│ Def(7, complex_foo$P46, [t], [{EDirect}], 
//│ None, 3, 
//│ let x0 = +(1,2)
//│   in let x1 = *(1,2)
//│     in t,x0,x1
//│ )
//│ Def(8, complex_foo$D47, [t,x0,x1], [{ESelect(w)},{EDirect},{EDirect}], 
//│ None, 1, 
//│ let x4 = t.w
//│   in let x5 = C(0)
//│     in let x6 = A(x4,x5)
//│       in let* (x76,x77,x78,x79,x80) = j2$P72(x6)
//│         in jump j2$D73(x76,x77,x78,x79,x80)
//│ )
//│ Def(15, j2$P72, [x12], [{EDirect}], 
//│ Some(ICtor(A)), 5, 
//│ let x13 = A(5,x12)
//│   in let x14 = B(6)
//│     in x13,x12,x0,x1,x14
//│ )
//│ Def(16, @join j2$D73, [x13,x12,x0,x1,x14], [{EDestruct，EDirect，ESelect(w)},{ESelect(x)，ESelect(w)},{EDirect},{EDirect},{EDestruct，EDirect，ESelect(w)}], 
//│ None, 1, 
//│ let x16 = x12.x
//│   in let x17 = x12.w
//│     in let x18 = +(x17,x0)
//│       in let x19 = +(x18,x1)
//│         in case x16 of
//│           A => let x22 = x16.w
//│             in jump j20(x22)
//│           B => jump j20(x19)
//│           C => jump j20(0)
//│ )
//│ },
//│ let* (x45) = bar()
//│   in x45)

:GraphOpt
class Pair(x, y)
fun inc_fst(pair) =
  let c = 2
  if pair is
    Pair(x1, x2) then x1 + c
fun foo() =
    let a = Pair(0, 1)
    let b = inc_fst(a)
    b
foo()
//│ |#class| |Pair|(|x|,| |y|)|↵|#fun| |inc_fst|(|pair|)| |#=|→|#let| |c| |#=| |2|↵|#if| |pair| |is|→|Pair|(|x1|,| |x2|)| |#then| |x1| |+| |c|←|←|↵|#fun| |foo|(||)| |#=|→|#let| |a| |#=| |Pair|(|0|,| |1|)|↵|#let| |b| |#=| |inc_fst|(|a|)|↵|b|←|↵|foo|(||)|
//│ Parsed: {class Pair(x, y,) {}; fun inc_fst = (pair,) => {let c = 2; if pair is ‹(Pair(x1, x2,)) then +(x1,)(c,)›}; fun foo = () => {let a = Pair(0, 1,); let b = inc_fst(a,); b}; foo()}
//│ Parsed:
//│ TypingUnit(NuTypeDef(class, Pair, (), Tup(_: Var(x), _: Var(y)), (), None, None, TypingUnit()), NuFunDef(None, inc_fst, None, [], Lam(Tup(_: Var(pair)), Blk(...))), NuFunDef(None, foo, None, [], Lam(Tup(), Blk(...))), App(Var(foo), Tup()))
//│ 
//│ GraphOpt:
//│ GOProgram({ClassInfo(0, Pair, [x,y])}, {
//│ Def(0, inc_fst, [pair], [{}], 
//│ None, 1, 
//│ let x0 = 2
//│   in let join j1(x5) = x5
//│     in case pair of
//│       Pair => let x2 = pair.y
//│         in let x3 = pair.x
//│           in let x4 = +(x3,x0)
//│             in jump j1(x4)
//│ )
//│ Def(1, foo, [], [{}], 
//│ None, 1, 
//│ let x6 = Pair(0,1)
//│   in let* (x7) = inc_fst(x6)
//│     in x7
//│ )
//│ },
//│ let* (x8) = foo()
//│   in x8)
//│ 
//│ Promoted ------------------------------------
//│ GOProgram({ClassInfo(0, Pair, [x,y])}, {
//│ Def(0, inc_fst, [pair], [{EDestruct，EDirect，ESelect(x)}], 
//│ None, 1, 
//│ case pair of
//│   Pair => let x3 = pair.x
//│     in let x4 = +(x3,2)
//│       in x4
//│ )
//│ Def(1, foo, [], [], 
//│ None, 1, 
//│ let x6 = Pair(0,1)
//│   in let* (x7) = inc_fst(x6)
//│     in x7
//│ )
//│ },
//│ let* (x8) = foo()
//│   in x8)
//│ 
//│ Optimized ------------------------------
//│ GOProgram({ClassInfo(0, Pair, [x,y])}, {
//│ Def(1, foo, [], [], 
//│ None, 1, 
//│ let* (x7) = inc_fst$D10$S12(0)
//│   in x7
//│ )
//│ Def(5, inc_fst$D10$S12, [pair_x], [{EDirect}], 
//│ None, 1, 
//│ let x4 = +(pair_x,2)
//│   in x4
//│ )
//│ },
//│ let* (x8) = foo()
//│   in x8)

:GraphOpt
class Pair(x, y)
fun inc_fst(pair) =
  let _ = 0
  if pair is
    Pair(x1, x2) then x2 + 1
fun foo() =
    let b = inc_fst(Pair(0, 1))
    b
foo()
//│ |#class| |Pair|(|x|,| |y|)|↵|#fun| |inc_fst|(|pair|)| |#=|→|#let| |_| |#=| |0|↵|#if| |pair| |is|→|Pair|(|x1|,| |x2|)| |#then| |x2| |+| |1|←|←|↵|#fun| |foo|(||)| |#=|→|#let| |b| |#=| |inc_fst|(|Pair|(|0|,| |1|)|)|↵|b|←|↵|foo|(||)|
//│ Parsed: {class Pair(x, y,) {}; fun inc_fst = (pair,) => {let _ = 0; if pair is ‹(Pair(x1, x2,)) then +(x2,)(1,)›}; fun foo = () => {let b = inc_fst(Pair(0, 1,),); b}; foo()}
//│ Parsed:
//│ TypingUnit(NuTypeDef(class, Pair, (), Tup(_: Var(x), _: Var(y)), (), None, None, TypingUnit()), NuFunDef(None, inc_fst, None, [], Lam(Tup(_: Var(pair)), Blk(...))), NuFunDef(None, foo, None, [], Lam(Tup(), Blk(...))), App(Var(foo), Tup()))
//│ 
//│ GraphOpt:
//│ GOProgram({ClassInfo(0, Pair, [x,y])}, {
//│ Def(0, inc_fst, [pair], [{}], 
//│ None, 1, 
//│ let x0 = 0
//│   in let join j1(x5) = x5
//│     in case pair of
//│       Pair => let x2 = pair.y
//│         in let x3 = pair.x
//│           in let x4 = +(x2,1)
//│             in jump j1(x4)
//│ )
//│ Def(1, foo, [], [{}], 
//│ None, 1, 
//│ let x6 = Pair(0,1)
//│   in let* (x7) = inc_fst(x6)
//│     in x7
//│ )
//│ },
//│ let* (x8) = foo()
//│   in x8)
//│ 
//│ Promoted ------------------------------------
//│ GOProgram({ClassInfo(0, Pair, [x,y])}, {
//│ Def(0, inc_fst, [pair], [{EDestruct，EDirect，ESelect(y)}], 
//│ None, 1, 
//│ case pair of
//│   Pair => let x2 = pair.y
//│     in let x4 = +(x2,1)
//│       in x4
//│ )
//│ Def(1, foo, [], [], 
//│ None, 1, 
//│ let x6 = Pair(0,1)
//│   in let* (x7) = inc_fst(x6)
//│     in x7
//│ )
//│ },
//│ let* (x8) = foo()
//│   in x8)
//│ 
//│ Optimized ------------------------------
//│ GOProgram({ClassInfo(0, Pair, [x,y])}, {
//│ Def(1, foo, [], [], 
//│ None, 1, 
//│ let* (x7) = inc_fst$D10$S12(1)
//│   in x7
//│ )
//│ Def(5, inc_fst$D10$S12, [pair_y], [{EDirect}], 
//│ None, 1, 
//│ let x4 = +(pair_y,1)
//│   in x4
//│ )
//│ },
//│ let* (x8) = foo()
//│   in x8)

:GraphOpt
class Left(x)
class Right(y)
fun foo(a, b) =
  let t = if a is
    Left(x) then Left(x + 1)
    Right(y) then Right(b)
  if t is
    Left(x) then x
    Right(y) then y
fun bar() =
  foo(Right(2), 2)
bar()
//│ |#class| |Left|(|x|)|↵|#class| |Right|(|y|)|↵|#fun| |foo|(|a|,| |b|)| |#=|→|#let| |t| |#=| |#if| |a| |is|→|Left|(|x|)| |#then| |Left|(|x| |+| |1|)|↵|Right|(|y|)| |#then| |Right|(|b|)|←|↵|#if| |t| |is|→|Left|(|x|)| |#then| |x|↵|Right|(|y|)| |#then| |y|←|←|↵|#fun| |bar|(||)| |#=|→|foo|(|Right|(|2|)|,| |2|)|←|↵|bar|(||)|
//│ Parsed: {class Left(x,) {}; class Right(y,) {}; fun foo = (a, b,) => {let t = if a is ‹(Left(x,)) then Left(+(x,)(1,),); (Right(y,)) then Right(b,)›; if t is ‹(Left(x,)) then x; (Right(y,)) then y›}; fun bar = () => {foo(Right(2,), 2,)}; bar()}
//│ Parsed:
//│ TypingUnit(NuTypeDef(class, Left, (), Tup(_: Var(x)), (), None, None, TypingUnit()), NuTypeDef(class, Right, (), Tup(_: Var(y)), (), None, None, TypingUnit()), NuFunDef(None, foo, None, [], Lam(Tup(_: Var(a), _: Var(b)), Blk(...))), NuFunDef(None, bar, None, [], Lam(Tup(), Blk(...))), App(Var(bar), Tup()))
//│ 
//│ GraphOpt:
//│ GOProgram({ClassInfo(0, Left, [x]),ClassInfo(1, Right, [y])}, {
//│ Def(0, foo, [a,b], [{}], 
//│ None, 1, 
//│ let join j0(x6) = let join j7(x10) = x10
//│       in case x6 of
//│         Left => let x8 = x6.x
//│           in jump j7(x8)
//│         Right => let x9 = x6.y
//│           in jump j7(x9)
//│   in case a of
//│     Left => let x1 = a.x
//│       in let x2 = +(x1,1)
//│         in let x3 = Left(x2)
//│           in jump j0(x3)
//│     Right => let x4 = a.y
//│       in let x5 = Right(b)
//│         in jump j0(x5)
//│ )
//│ Def(1, bar, [], [{}], 
//│ None, 1, 
//│ let x11 = Right(2)
//│   in let* (x12) = foo(x11,2)
//│     in x12
//│ )
//│ },
//│ let* (x13) = bar()
//│   in x13)
//│ 
//│ Promoted ------------------------------------
//│ GOProgram({ClassInfo(0, Left, [x]),ClassInfo(1, Right, [y])}, {
//│ Def(0, foo, [a,b], [{EDestruct，EDirect，ESelect(x)},{EDirect}], 
//│ None, 1, 
//│ case a of
//│   Left => let x1 = a.x
//│     in let x2 = +(x1,1)
//│       in let x3 = Left(x2)
//│         in jump j0(x3)
//│   Right => let x5 = Right(b)
//│     in jump j0(x5)
//│ )
//│ Def(1, bar, [], [], 
//│ None, 1, 
//│ let x11 = Right(2)
//│   in let* (x12) = foo(x11,2)
//│     in x12
//│ )
//│ Def(2, @join j0, [x6], [{EDestruct，EDirect，ESelect(x)，ESelect(y)}], 
//│ None, 1, 
//│ case x6 of
//│   Left => let x8 = x6.x
//│     in x8
//│   Right => let x9 = x6.y
//│     in x9
//│ )
//│ },
//│ let* (x13) = bar()
//│   in x13)
//│ 
//│ Optimized ------------------------------
//│ GOProgram({ClassInfo(0, Left, [x]),ClassInfo(1, Right, [y])}, {
//│ Def(1, bar, [], [], 
//│ None, 1, 
//│ let* (x12) = foo$D16(2)
//│   in x12
//│ )
//│ Def(2, @join j0, [x6], [{EDestruct，EDirect，ESelect(x)，ESelect(y)}], 
//│ None, 1, 
//│ case x6 of
//│   Left => let x8 = x6.x
//│     in x8
//│   Right => let x9 = x6.y
//│     in x9
//│ )
//│ Def(6, foo$D16, [b], [{EDirect}], 
//│ None, 1, 
//│ let x5 = Right(b)
//│   in jump j0(x5)
//│ )
//│ },
//│ let* (x13) = bar()
//│   in x13)
//│ 
//│ Optimized ------------------------------
//│ GOProgram({ClassInfo(0, Left, [x]),ClassInfo(1, Right, [y])}, {
//│ Def(1, bar, [], [], 
//│ None, 1, 
//│ 2
//│ )
//│ },
//│ let* (x13) = bar()
//│   in x13)

:GraphOpt
class True
class False
class Pair(x, y)
fun foo(a) = a.x + a.y
fun bar() =
  foo(Pair(1, 0))
bar()
//│ |#class| |True|↵|#class| |False|↵|#class| |Pair|(|x|,| |y|)|↵|#fun| |foo|(|a|)| |#=| |a|.x| |+| |a|.y|↵|#fun| |bar|(||)| |#=|→|foo|(|Pair|(|1|,| |0|)|)|←|↵|bar|(||)|
//│ Parsed: {class True {}; class False {}; class Pair(x, y,) {}; fun foo = (a,) => +((a).x,)((a).y,); fun bar = () => {foo(Pair(1, 0,),)}; bar()}
//│ Parsed:
//│ TypingUnit(NuTypeDef(class, True, (), Tup(), (), None, None, TypingUnit()), NuTypeDef(class, False, (), Tup(), (), None, None, TypingUnit()), NuTypeDef(class, Pair, (), Tup(_: Var(x), _: Var(y)), (), None, None, TypingUnit()), NuFunDef(None, foo, None, [], Lam(Tup(_: Var(a)), App(App(Var(+), Tup(_: Sel(Var(a), x))), Tup(_: Sel(Var(a), y))))), NuFunDef(None, bar, None, [], Lam(Tup(), Blk(...))), App(Var(bar), Tup()))
//│ 
//│ GraphOpt:
//│ GOProgram({ClassInfo(0, True, []),ClassInfo(1, False, []),ClassInfo(2, Pair, [x,y])}, {
//│ Def(0, foo, [a], [{}], 
//│ None, 1, 
//│ let x0 = a.x
//│   in let x1 = a.y
//│     in let x2 = +(x0,x1)
//│       in x2
//│ )
//│ Def(1, bar, [], [{}], 
//│ None, 1, 
//│ let x3 = Pair(1,0)
//│   in let* (x4) = foo(x3)
//│     in x4
//│ )
//│ },
//│ let* (x5) = bar()
//│   in x5)
//│ 
//│ Promoted ------------------------------------
//│ GOProgram({ClassInfo(0, True, []),ClassInfo(1, False, []),ClassInfo(2, Pair, [x,y])}, {
//│ Def(0, foo, [a], [{ESelect(x)，ESelect(y)}], 
//│ None, 1, 
//│ let x0 = a.x
//│   in let x1 = a.y
//│     in let x2 = +(x0,x1)
//│       in x2
//│ )
//│ Def(1, bar, [], [], 
//│ None, 1, 
//│ let x3 = Pair(1,0)
//│   in let* (x4) = foo(x3)
//│     in x4
//│ )
//│ },
//│ let* (x5) = bar()
//│   in x5)
//│ 
//│ Optimized ------------------------------
//│ GOProgram({ClassInfo(0, True, []),ClassInfo(1, False, []),ClassInfo(2, Pair, [x,y])}, {
//│ Def(1, bar, [], [], 
//│ None, 1, 
//│ let* (x4) = foo$S6(1,0)
//│   in x4
//│ )
//│ Def(2, foo$S6, [a_x,a_y], [{EDirect},{EDirect}], 
//│ None, 1, 
//│ let x2 = +(a_x,a_y)
//│   in x2
//│ )
//│ },
//│ let* (x5) = bar()
//│   in x5)


:GraphOpt
class C1(x, y)
class C2(z)
fun foo(a) = if a is
  C1(x, y) then x
  C2(z) then z
fun bar(b) =
  foo(C1(0, 1))
bar()
//│ |#class| |C1|(|x|,| |y|)|↵|#class| |C2|(|z|)|↵|#fun| |foo|(|a|)| |#=| |#if| |a| |is|→|C1|(|x|,| |y|)| |#then| |x|↵|C2|(|z|)| |#then| |z|←|↵|#fun| |bar|(|b|)| |#=|→|foo|(|C1|(|0|,| |1|)|)|←|↵|bar|(||)|
//│ Parsed: {class C1(x, y,) {}; class C2(z,) {}; fun foo = (a,) => if a is ‹(C1(x, y,)) then x; (C2(z,)) then z›; fun bar = (b,) => {foo(C1(0, 1,),)}; bar()}
//│ Parsed:
//│ TypingUnit(NuTypeDef(class, C1, (), Tup(_: Var(x), _: Var(y)), (), None, None, TypingUnit()), NuTypeDef(class, C2, (), Tup(_: Var(z)), (), None, None, TypingUnit()), NuFunDef(None, foo, None, [], Lam(Tup(_: Var(a)), If(IfOpApp(Var(a), Var(is), IfBlock(IfThen(App(Var(C1), Tup(_: Var(x), _: Var(y))), Var(x);IfThen(App(Var(C2), Tup(_: Var(z))), Var(z)), None))), NuFunDef(None, bar, None, [], Lam(Tup(_: Var(b)), Blk(...))), App(Var(bar), Tup()))
//│ 
//│ GraphOpt:
//│ GOProgram({ClassInfo(0, C1, [x,y]),ClassInfo(1, C2, [z])}, {
//│ Def(0, foo, [a], [{}], 
//│ None, 1, 
//│ let join j0(x4) = x4
//│   in case a of
//│     C1 => let x1 = a.y
//│       in let x2 = a.x
//│         in jump j0(x2)
//│     C2 => let x3 = a.z
//│       in jump j0(x3)
//│ )
//│ Def(1, bar, [b], [{}], 
//│ None, 1, 
//│ let x5 = C1(0,1)
//│   in let* (x6) = foo(x5)
//│     in x6
//│ )
//│ },
//│ let* (x7) = bar()
//│   in x7)
//│ 
//│ Promoted ------------------------------------
//│ GOProgram({ClassInfo(0, C1, [x,y]),ClassInfo(1, C2, [z])}, {
//│ Def(0, foo, [a], [{EDestruct，EDirect，ESelect(x)，ESelect(z)}], 
//│ None, 1, 
//│ case a of
//│   C1 => let x2 = a.x
//│     in x2
//│   C2 => let x3 = a.z
//│     in x3
//│ )
//│ Def(1, bar, [b], [{}], 
//│ None, 1, 
//│ let x5 = C1(0,1)
//│   in let* (x6) = foo(x5)
//│     in x6
//│ )
//│ },
//│ let* (x7) = bar()
//│   in x7)
//│ 
//│ Optimized ------------------------------
//│ GOProgram({ClassInfo(0, C1, [x,y]),ClassInfo(1, C2, [z])}, {
//│ Def(1, bar, [b], [{}], 
//│ None, 1, 
//│ 0
//│ )
//│ },
//│ let* (x7) = bar()
//│   in x7)

:GraphOpt
class Pair(x, y)
fun foo(a, b) =
  let x1 = a.x
  let y1 = a.y
  let x2 = b.x
  let y2 = b.y
  x1 + y1 + x2 + y2
fun bar(c) =
  foo(Pair(0, 1), c)
  foo(c, Pair(2, 3))
  foo(Pair(0, 1), Pair(2, 3))
fun baz() =
  bar(Pair(4,5))
baz()
//│ |#class| |Pair|(|x|,| |y|)|↵|#fun| |foo|(|a|,| |b|)| |#=|→|#let| |x1| |#=| |a|.x|↵|#let| |y1| |#=| |a|.y|↵|#let| |x2| |#=| |b|.x|↵|#let| |y2| |#=| |b|.y|↵|x1| |+| |y1| |+| |x2| |+| |y2|←|↵|#fun| |bar|(|c|)| |#=|→|foo|(|Pair|(|0|,| |1|)|,| |c|)|↵|foo|(|c|,| |Pair|(|2|,| |3|)|)|↵|foo|(|Pair|(|0|,| |1|)|,| |Pair|(|2|,| |3|)|)|←|↵|#fun| |baz|(||)| |#=|→|bar|(|Pair|(|4|,|5|)|)|←|↵|baz|(||)|
//│ Parsed: {class Pair(x, y,) {}; fun foo = (a, b,) => {let x1 = (a).x; let y1 = (a).y; let x2 = (b).x; let y2 = (b).y; +(+(+(x1,)(y1,),)(x2,),)(y2,)}; fun bar = (c,) => {foo(Pair(0, 1,), c,); foo(c, Pair(2, 3,),); foo(Pair(0, 1,), Pair(2, 3,),)}; fun baz = () => {bar(Pair(4, 5,),)}; baz()}
//│ Parsed:
//│ TypingUnit(NuTypeDef(class, Pair, (), Tup(_: Var(x), _: Var(y)), (), None, None, TypingUnit()), NuFunDef(None, foo, None, [], Lam(Tup(_: Var(a), _: Var(b)), Blk(...))), NuFunDef(None, bar, None, [], Lam(Tup(_: Var(c)), Blk(...))), NuFunDef(None, baz, None, [], Lam(Tup(), Blk(...))), App(Var(baz), Tup()))
//│ 
//│ GraphOpt:
//│ GOProgram({ClassInfo(0, Pair, [x,y])}, {
//│ Def(0, foo, [a,b], [{}], 
//│ None, 1, 
//│ let x0 = a.x
//│   in let x1 = a.y
//│     in let x2 = b.x
//│       in let x3 = b.y
//│         in let x4 = +(x0,x1)
//│           in let x5 = +(x4,x2)
//│             in let x6 = +(x5,x3)
//│               in x6
//│ )
//│ Def(1, bar, [c], [{}], 
//│ None, 1, 
//│ let x7 = Pair(0,1)
//│   in let* (x8) = foo(x7,c)
//│     in let x9 = Pair(2,3)
//│       in let* (x10) = foo(c,x9)
//│         in let x11 = Pair(0,1)
//│           in let x12 = Pair(2,3)
//│             in let* (x13) = foo(x11,x12)
//│               in x13
//│ )
//│ Def(2, baz, [], [{}], 
//│ None, 1, 
//│ let x14 = Pair(4,5)
//│   in let* (x15) = bar(x14)
//│     in x15
//│ )
//│ },
//│ let* (x16) = baz()
//│   in x16)
//│ 
//│ Promoted ------------------------------------
//│ GOProgram({ClassInfo(0, Pair, [x,y])}, {
//│ Def(0, foo, [a,b], [{ESelect(x)，ESelect(y)},{ESelect(x)，ESelect(y)}], 
//│ None, 1, 
//│ let x0 = a.x
//│   in let x1 = a.y
//│     in let x2 = b.x
//│       in let x3 = b.y
//│         in let x4 = +(x0,x1)
//│           in let x5 = +(x4,x2)
//│             in let x6 = +(x5,x3)
//│               in x6
//│ )
//│ Def(1, bar, [c], [{EDirect，ESelect(x)，ESelect(y)}], 
//│ None, 1, 
//│ let x7 = Pair(0,1)
//│   in let* (x8) = foo(x7,c)
//│     in let x9 = Pair(2,3)
//│       in let* (x10) = foo(c,x9)
//│         in let x11 = Pair(0,1)
//│           in let x12 = Pair(2,3)
//│             in let* (x13) = foo(x11,x12)
//│               in x13
//│ )
//│ Def(2, baz, [], [], 
//│ None, 1, 
//│ let x14 = Pair(4,5)
//│   in let* (x15) = bar(x14)
//│     in x15
//│ )
//│ },
//│ let* (x16) = baz()
//│   in x16)
//│ 
//│ Optimized ------------------------------
//│ GOProgram({ClassInfo(0, Pair, [x,y])}, {
//│ Def(1, bar, [c], [{ESelect(x)，ESelect(y)}], 
//│ None, 1, 
//│ let x20 = c.x
//│   in let x21 = c.y
//│     in let* (x8) = foo$S17(0,1,x20,x21)
//│       in let* (x10) = foo$S17(x20,x21,2,3)
//│         in let* (x13) = foo$S17(0,1,2,3)
//│           in x13
//│ )
//│ Def(2, baz, [], [], 
//│ None, 1, 
//│ let x14 = Pair(4,5)
//│   in let* (x15) = bar(x14)
//│     in x15
//│ )
//│ Def(3, foo$S17, [a_x,a_y,b_x,b_y], [{EDirect},{EDirect},{EDirect},{EDirect}], 
//│ None, 1, 
//│ let x4 = +(a_x,a_y)
//│   in let x5 = +(x4,b_x)
//│     in let x6 = +(x5,b_y)
//│       in x6
//│ )
//│ },
//│ let* (x16) = baz()
//│   in x16)
//│ 
//│ Optimized ------------------------------
//│ GOProgram({ClassInfo(0, Pair, [x,y])}, {
//│ Def(2, baz, [], [], 
//│ None, 1, 
//│ let* (x15) = bar$S28(4,5)
//│   in x15
//│ )
//│ Def(3, foo$S17, [a_x,a_y,b_x,b_y], [{EDirect},{EDirect},{EDirect},{EDirect}], 
//│ None, 1, 
//│ let x4 = +(a_x,a_y)
//│   in let x5 = +(x4,b_x)
//│     in let x6 = +(x5,b_y)
//│       in x6
//│ )
//│ Def(4, bar$S28, [c_x,c_y], [{EDirect},{EDirect}], 
//│ None, 1, 
//│ let* (x8) = foo$S17(0,1,c_x,c_y)
//│   in let* (x10) = foo$S17(c_x,c_y,2,3)
//│     in let* (x13) = foo$S17(0,1,2,3)
//│       in x13
//│ )
//│ },
//│ let* (x16) = baz()
//│   in x16)

:GraphOpt
class Pair(x, y)
fun foo() =
  let p = Pair(0, 1)
  let b = p.x
  b
foo()
//│ |#class| |Pair|(|x|,| |y|)|↵|#fun| |foo|(||)| |#=|→|#let| |p| |#=| |Pair|(|0|,| |1|)|↵|#let| |b| |#=| |p|.x|↵|b|←|↵|foo|(||)|
//│ Parsed: {class Pair(x, y,) {}; fun foo = () => {let p = Pair(0, 1,); let b = (p).x; b}; foo()}
//│ Parsed:
//│ TypingUnit(NuTypeDef(class, Pair, (), Tup(_: Var(x), _: Var(y)), (), None, None, TypingUnit()), NuFunDef(None, foo, None, [], Lam(Tup(), Blk(...))), App(Var(foo), Tup()))
//│ 
//│ GraphOpt:
//│ GOProgram({ClassInfo(0, Pair, [x,y])}, {
//│ Def(0, foo, [], [{}], 
//│ None, 1, 
//│ let x0 = Pair(0,1)
//│   in let x1 = x0.x
//│     in x1
//│ )
//│ },
//│ let* (x2) = foo()
//│   in x2)
//│ 
//│ Promoted ------------------------------------
//│ GOProgram({ClassInfo(0, Pair, [x,y])}, {
//│ Def(0, foo, [], [], 
//│ None, 1, 
//│ 0
//│ )
//│ },
//│ let* (x2) = foo()
//│   in x2)

